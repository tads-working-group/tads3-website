<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>misc.t</title></head><body>
<table class=ban><tr><td><h1>misc.t</h1><td align=right><a href="../file/misc.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved. 
<a name="5"></a> *   Adapted for adv3Lite by Eric Eve
<a name="6"></a> *   
<a name="7"></a> *   adv3Lite Library - miscellaneous definitions
<a name="8"></a> *   
<a name="9"></a> *   This module contains miscellaneous definitions that don't have a
<a name="10"></a> *   natural grouping with any larger modules, and which aren't complex
<a name="11"></a> *   enough to justify modules of their own.  
<a name="12"></a> */
<a name="13"></a>
<a name="14"></a>/* include the library header */
<a name="15"></a>#include "advlite.h"
<a name="16"></a>
<a name="17"></a>
<a name="18"></a>/* ------------------------------------------------------------------------ */
<a name="19"></a>/*
<a name="20"></a> *   When a call is made to a property not defined or inherited by the
<a name="21"></a> *   target object, the system will automatically invoke this method.  The
<a name="22"></a> *   method will be invoked with a property pointer as its first argument,
<a name="23"></a> *   and the original arguments as the remaining arguments.  The first
<a name="24"></a> *   argument gives the property that was invoked and not defined by the
<a name="25"></a> *   object.  A typical definition in an object would look like this:
<a name="26"></a> *   
<a name="27"></a> *   propNotDefined(prop, [args]) { ... }
<a name="28"></a> *   
<a name="29"></a> *   If this method is not defined by the object, the system simply
<a name="30"></a> *   returns nil as the value of the undefined property evaluation or
<a name="31"></a> *   method invocation.
<a name="32"></a> */
<a name="33"></a>property propNotDefined;
<a name="34"></a>export propNotDefined;
<a name="35"></a>
<a name="36"></a>
<a name="37"></a>/* ------------------------------------------------------------------------ */
<a name="38"></a>/*
<a name="39"></a> *   We refer to some properties defined primarily in score.t - that's an
<a name="40"></a> *   optional module, though, so make sure the compiler has heard of these. 
<a name="41"></a> */
<a name="42"></a>property calcMaxScore, runScoreNotifier;
<a name="43"></a>
<a name="44"></a>
<a name="45"></a>/* ------------------------------------------------------------------------ */
<a name="46"></a>/*
<a name="47"></a> *   The library base class for the gameMain object.
<a name="48"></a> *   
<a name="49"></a> *   Each game MUST define an object called 'gameMain' to define how the
<a name="50"></a> *   game starts up.  You can use GameMainDef as the base class of your
<a name="51"></a> *   'gameMain' object, in which case the only thing you're required to
<a name="52"></a> *   specify in your object is the 'initialPlayerChar' property - you can
<a name="53"></a> *   inherit everything else from the GameMainDef class if you don't
<a name="54"></a> *   require any further customizations.  
<a name="55"></a> */
<a name="56"></a>class GameMainDef: object
<a name="57"></a>    /*
<a name="58"></a>     *   The initial player character.  Each game's 'gameMain' object MUST
<a name="59"></a>     *   define this to refer to the Actor object that serves as the
<a name="60"></a>     *   initial player character. 
<a name="61"></a>     */
<a name="62"></a>    initialPlayerChar = nil
<a name="63"></a>
<a name="64"></a>    /*
<a name="65"></a>     *   Show the game's introduction.  This routine is called by the
<a name="66"></a>     *   default newGame() just before entering the main command loop.  The
<a name="67"></a>     *   command loop starts off by showing the initial room description,
<a name="68"></a>     *   so there's no need to do that here.
<a name="69"></a>     *   
<a name="70"></a>     *   Most games will want to override this, to show a prologue message
<a name="71"></a>     *   setting up the game's initial situation for the player.  We don't
<a name="72"></a>     *   show anything by default.  
<a name="73"></a>     */
<a name="74"></a>    showIntro() { }
<a name="75"></a>
<a name="76"></a>    /*
<a name="77"></a>     *   Show the "goodbye" message.  This is called after the main command
<a name="78"></a>     *   loop terminates.
<a name="79"></a>     *   
<a name="80"></a>     *   We don't show anything by default.  If you want to show a "thanks
<a name="81"></a>     *   for playing" type of message as the game exits, override this
<a name="82"></a>     *   routine with the desired text.  
<a name="83"></a>     */
<a name="84"></a>    showGoodbye() { }
<a name="85"></a>
<a name="86"></a>    /*
<a name="87"></a>     *   Begin a new game.  This default implementation shows the
<a name="88"></a>     *   introductory message, calls the main command loop, and finally
<a name="89"></a>     *   shows the goodbye message.
<a name="90"></a>     *   
<a name="91"></a>     *   You can override this routine if you want to customize the startup
<a name="92"></a>     *   protocol.  For example, if you want to create a pre-game options
<a name="93"></a>     *   menu, you could override this routine to show the list of options
<a name="94"></a>     *   and process the user's input.  If you need only to customize the
<a name="95"></a>     *   introduction and goodbye messages, you can simply override
<a name="96"></a>     *   showIntro() and showGoodbye() instead.  
<a name="97"></a>     */
<a name="98"></a>    newGame()
<a name="99"></a>    {
<a name="100"></a>        /*   Create an action context in case any startup code needs it */
<a name="101"></a>        gAction = Look.createInstance();
<a name="102"></a>        gActor = initialPlayerChar;
<a name="103"></a>
<a name="104"></a>        
<a name="105"></a>        /* 
<a name="106"></a>         *   Show the statusline before we display our introductory.  This
<a name="107"></a>         *   will help minimize redrawing - if we waited until after
<a name="108"></a>         *   displaying some text, we might have to redraw some of the
<a name="109"></a>         *   screen to rearrange things for the new screen area taken up by
<a name="110"></a>         *   the status line, which could be visible to the user.  By
<a name="111"></a>         *   setting up the status line first, we'll probably have less to
<a name="112"></a>         *   redraw because we won't have anything on the screen yet when
<a name="113"></a>         *   figuring the layout.  
<a name="114"></a>         */
<a name="115"></a>        statusLine.showStatusLine();
<a name="116"></a>
<a name="117"></a>        /* show the introduction */
<a name="118"></a>        showIntro();
<a name="119"></a>
<a name="120"></a>        /* run the game, showing the initial location's full description */
<a name="121"></a>        runGame(true);
<a name="122"></a>
<a name="123"></a>        /* show the end-of-game message */
<a name="124"></a>        showGoodbye();
<a name="125"></a>    }
<a name="126"></a>
<a name="127"></a>    /*
<a name="128"></a>     *   Restore a game and start it running.  This is invoked when the
<a name="129"></a>     *   user launches the interpreter using a saved game file; for
<a name="130"></a>     *   example, on a Macintosh, this happens when the user double-clicks
<a name="131"></a>     *   on a saved game file on the desktop.
<a name="132"></a>     *   
<a name="133"></a>     *   This default implementation bypasses any normal introduction
<a name="134"></a>     *   messages: we simply restore the game file if possible, and
<a name="135"></a>     *   immediately start the game's main command loop.  Most games won't
<a name="136"></a>     *   need to override this, but you can if you need some special effect
<a name="137"></a>     *   in the restore-at-startup case.  
<a name="138"></a>     */
<a name="139"></a>    restoreAndRunGame(filename)
<a name="140"></a>    {
<a name="141"></a>        local succ;
<a name="142"></a>
<a name="143"></a>        /* mention that we're about to restore the saved position */
<a name="144"></a>        DMsg(note main restore, 'Game restored.&lt;.p&gt;');
<a name="145"></a>
<a name="146"></a>        /* try restoring it */
<a name="147"></a>        succ = Restore.startupRestore(filename);
<a name="148"></a>
<a name="149"></a>        /* show a blank line after the restore result message */
<a name="150"></a>        "&lt;.p&gt;";
<a name="151"></a>
<a name="152"></a>        /* if we were successful, run the game */
<a name="153"></a>        if (succ)
<a name="154"></a>        {
<a name="155"></a>            /* 
<a name="156"></a>             *   Run the command loop.  There's no need to show the room
<a name="157"></a>             *   description, since the RESTORE action will have already
<a name="158"></a>             *   done so. 
<a name="159"></a>             */
<a name="160"></a>            runGame(nil);
<a name="161"></a>
<a name="162"></a>            /* show the end-of-game message */
<a name="163"></a>            showGoodbye();
<a name="164"></a>        }
<a name="165"></a>    }
<a name="166"></a>
<a name="167"></a>    /*
<a name="168"></a>     *   Set the interpreter window title, if applicable to the local
<a name="169"></a>     *   platform.  This simply displays a &lt;TITLE&gt; tag to set the title to
<a name="170"></a>     *   the string found in the versionInfo object.  
<a name="171"></a>     */
<a name="172"></a>    setGameTitle()
<a name="173"></a>    {
<a name="174"></a>        /* write the &lt;TITLE&gt; tag with the game's name */
<a name="175"></a>        "&lt;title&gt;&lt;&lt;versionInfo.name&gt;&gt;&lt;/title&gt;";
<a name="176"></a>    }
<a name="177"></a>
<a name="178"></a>    /*
<a name="179"></a>     *   Set up the HTML-mode about-box.  By default, this does nothing.
<a name="180"></a>     *   Games can use this routine to show an &lt;ABOUTBOX&gt; tag, if desired,
<a name="181"></a>     *   to set up the contents of an about-box for HTML TADS platforms.
<a name="182"></a>     *   
<a name="183"></a>     *   Note that an &lt;ABOUTBOX&gt; tag must be re-initialized each time the
<a name="184"></a>     *   main game window is cleared, so this routine should be called
<a name="185"></a>     *   again after any call to clearScreen().  
<a name="186"></a>     */
<a name="187"></a>    setAboutBox()
<a name="188"></a>    {
<a name="189"></a>        /* we don't show any about-box by default */
<a name="190"></a>    }
<a name="191"></a>
<a name="192"></a>    /*
<a name="193"></a>     *   Build a saved game metadata table.  This returns a LookupTable
<a name="194"></a>     *   containing string key/value pairs that are stored in saved game
<a name="195"></a>     *   files, providing descriptive information that can be displayed to
<a name="196"></a>     *   the user when browsing a collection of save files.  This is called
<a name="197"></a>     *   each time we execute a SAVE command, so that we store the current
<a name="198"></a>     *   context of the game.
<a name="199"></a>     *   
<a name="200"></a>     *   Some interpreters display information from this table when
<a name="201"></a>     *   presenting the user with a list of files for RESTORE.  The
<a name="202"></a>     *   contents of the table are intentionally open-ended to allow for
<a name="203"></a>     *   future extensions, but at the moment, the following keys are
<a name="204"></a>     *   specifically defined (note that capitalization must be exact):
<a name="205"></a>     *   
<a name="206"></a>     *   UserDesc - descriptive text entered by the user (this should
<a name="207"></a>     *   simply be the contents of the 'userDesc' parameter).  This is
<a name="208"></a>     *   treated as ordinary plain text (i.e., no HTML or other markups are
<a name="209"></a>     *   interpreted in this text).
<a name="210"></a>     *   
<a name="211"></a>     *   AutoDesc - descriptive text generated by the game to describe the
<a name="212"></a>     *   saved position.  This text can contain the simple HTML markups
<a name="213"></a>     *   &lt;b&gt;..&lt;/b&gt;, &lt;i&gt;..&lt;/i&gt;, and &lt;br&gt; for formatting.
<a name="214"></a>     *   
<a name="215"></a>     *   Return nil if you don't want to save any metadata information.  
<a name="216"></a>     *   
<a name="217"></a>     *   'userDesc' is an optional string entered by the user via the Save
<a name="218"></a>     *   Game dialog.  Some interpreters let the user enter a description
<a name="219"></a>     *   for a saved game via the file selector dialog; the descriptive
<a name="220"></a>     *   text is separate from the filename, and is intended to let the
<a name="221"></a>     *   user enter a more free-form description than would be allowed in a
<a name="222"></a>     *   filename.  This text, if any, is passed to use via the 'userDesc'
<a name="223"></a>     *   parameter.  
<a name="224"></a>     */
<a name="225"></a>    getSaveDesc(userDesc)
<a name="226"></a>    {
<a name="227"></a>        /* create the lookup table */
<a name="228"></a>        local t = new LookupTable();
<a name="229"></a>
<a name="230"></a>        /* store the user description, if provided */
<a name="231"></a>        if (userDesc != nil)
<a name="232"></a>            t['UserDesc'] = userDesc;
<a name="233"></a>
<a name="234"></a>        /* start our auto description with the current room name */
<a name="235"></a>        desc = gPlayerChar.outermostVisibleParent().roomTitle + '; ';
<a name="236"></a>        
<a name="237"></a>        /* if we're keeping score, include the score */
<a name="238"></a>        if (libGlobal.scoreObj != nil)
<a name="239"></a>            desc += toString(libGlobal.scoreObj.totalScore) + ' points in ';
<a name="240"></a>
<a name="241"></a>        /* add the number of turns so far */
<a name="242"></a>        desc += toString(libGlobal.totalTurns) + ' moves';
<a name="243"></a>
<a name="244"></a>        /* add the auto description */
<a name="245"></a>        t['AutoDesc'] = desc;
<a name="246"></a>
<a name="247"></a>        /* return the table */
<a name="248"></a>        return t;
<a name="249"></a>    }
<a name="250"></a>
<a name="251"></a>    /*
<a name="252"></a>     *   The gameMain object also specifies some settings that control
<a name="253"></a>     *   optional library behavior.  If you want the standard library
<a name="254"></a>     *   behavior, you can just inherit the default settings from this
<a name="255"></a>     *   class.  Some games might want to select non-default variations,
<a name="256"></a>     *   though.  
<a name="257"></a>     */
<a name="258"></a>
<a name="259"></a>    /* 
<a name="260"></a>     *   The maximum number of points possible in the game.  If the game
<a name="261"></a>     *   includes the scoring module at all, and this is non-nil, the SCORE
<a name="262"></a>     *   and FULL SCORE commands will display this value to the player as a
<a name="263"></a>     *   rough indication of how much farther there is to go in the game.
<a name="264"></a>     *   
<a name="265"></a>     *   By default, we initialize this on demand, by calculating the sum
<a name="266"></a>     *   of the point values of the Achievement objects in the game.  The
<a name="267"></a>     *   game can override this if needed to specify a specific maximum
<a name="268"></a>     *   possible score, rather than relying on the automatic calculation.
<a name="269"></a>     */
<a name="270"></a>    maxScore()
<a name="271"></a>    {
<a name="272"></a>        local m;
<a name="273"></a>        
<a name="274"></a>        /* ask the score module (if any) to compute the maximum score */
<a name="275"></a>        m = (libGlobal.scoreObj != nil
<a name="276"></a>             ? libGlobal.scoreObj.calcMaxScore : nil);
<a name="277"></a>
<a name="278"></a>        /* supersede this initializer with the calculated value */
<a name="279"></a>        maxScore = m;
<a name="280"></a>
<a name="281"></a>        /* return the result */
<a name="282"></a>        return m;
<a name="283"></a>    }
<a name="284"></a>
<a name="285"></a>    /*
<a name="286"></a>     *   The score ranking list - this provides a list of names for
<a name="287"></a>     *   various score levels.  If the game provides a non-nil list here,
<a name="288"></a>     *   the SCORE and FULL SCORE commands will show the rank along with
<a name="289"></a>     *   the score ("This makes you a Master Adventurer").
<a name="290"></a>     *   
<a name="291"></a>     *   This is a list of score entries.  Each score entry is itself a
<a name="292"></a>     *   list of two elements: the first element is the minimum score for
<a name="293"></a>     *   the rank, and the second is a string describing the rank.  The
<a name="294"></a>     *   ranks should be given in ascending order, since we simply search
<a name="295"></a>     *   the list for the first item whose minimum score is greater than
<a name="296"></a>     *   our score, and use the preceding item.  The first entry in the
<a name="297"></a>     *   list would normally have a minimum of zero points, since it
<a name="298"></a>     *   should give the initial, lowest rank.
<a name="299"></a>     *   
<a name="300"></a>     *   If this is set to nil, which it is by default, we'll simply skip
<a name="301"></a>     *   score ranks entirely.  
<a name="302"></a>     */
<a name="303"></a>    scoreRankTable = nil
<a name="304"></a>
<a name="305"></a>    
<a name="306"></a>    /*  
<a name="307"></a>     *   If this flag is true then room description listings and examine
<a name="308"></a>     *   listings use a parenthetical style to show subcontents (e.g. "On the
<a name="309"></a>     *   table you see a box (in which is a brass key)") instead of showing each
<a name="310"></a>     *   item and its contents in a separate paragraph.
<a name="311"></a>     */    
<a name="312"></a>    useParentheticalListing = nil
<a name="313"></a>    
<a name="314"></a>    /* 
<a name="315"></a>     *   If this flag is true then room description listings will include a
<a name="316"></a>     *   paragraph break between each set of subcontents listings (i.e. the
<a name="317"></a>     *   listing of the contents of each item in the room that has visible
<a name="318"></a>     *   contents). If it is nil the subcontents listings will all be run into a
<a name="319"></a>     *   single paragraph. Note that the global setting defined here can be
<a name="320"></a>     *   overridden on individual rooms.
<a name="321"></a>     */
<a name="322"></a>    paraBrksBtwnSubcontents = true
<a name="323"></a>        
<a name="324"></a>
<a name="325"></a>    /*
<a name="326"></a>     *   Option flag: allow ALL to be used for every verb.  This is true by
<a name="327"></a>     *   default, which means that players will be allowed to use ALL with
<a name="328"></a>     *   any command - OPEN ALL, EXAMINE ALL, etc.
<a name="329"></a>     *   
<a name="330"></a>     *   Some authors don't like to allow players to use ALL with so many
<a name="331"></a>     *   verbs, because they think it's a sort of "cheating" when players
<a name="332"></a>     *   try things like OPEN ALL.  This option lets you disable ALL for
<a name="333"></a>     *   most verbs; if you set this to nil, only the basic inventory
<a name="334"></a>     *   management verbs (TAKE, TAKE FROM, DROP, PUT IN, PUT ON) will
<a name="335"></a>     *   allow ALL, and other verbs will simply respond with an error
<a name="336"></a>     *   ("'All' isn't allowed with that verb").
<a name="337"></a>     *   
<a name="338"></a>     *   If you're writing an especially puzzle-oriented game, you might
<a name="339"></a>     *   want to set this to nil.  It's a trade-off though, as some people
<a name="340"></a>     *   will think your game is less player-friendly if you disable ALL.  
<a name="341"></a>     */
<a name="342"></a>    allVerbsAllowAll = true
<a name="343"></a>
<a name="344"></a>    
<a name="345"></a>    /*
<a name="346"></a>     *   Should the "before" notifications (beforeAction, roomBeforeAction, and
<a name="347"></a>     *   actorAction) run before or after the "check" phase?
<a name="348"></a>     *
<a name="349"></a>     *   In many ways it's more logical and useful to run "check" first.  That
<a name="350"></a>     *   way, you can consider the action to be more or less committed by the
<a name="351"></a>     *   time the "before" notifiers are invoked.  Of course, a command is never
<a name="352"></a>     *   truly* committed until it's actually been executed, since a "before"
<a name="353"></a>     *   handler could always cancel it.  But this is relatively rare - "before"
<a name="354"></a>     *   handlers usually carry out side effects, so it's very useful to be able
<a name="355"></a>     *   to know that the command has already passed all of its own internal
<a name="356"></a>     *   checks by the time "before" is invoked - that way, you can invoke side
<a name="357"></a>     *   effects without worrying that the command will subsequently fail.
<a name="358"></a>     */
<a name="359"></a>    beforeRunsBeforeCheck = nil
<a name="360"></a>    
<a name="361"></a>    /* 
<a name="362"></a>     *   Flag, should this game be in the past tense. By default the game is in
<a name="363"></a>     *   the present tense.
<a name="364"></a>     *
<a name="365"></a>     *   For a wider selection of tenses override Narrator.tense instead.
<a name="366"></a>     */
<a name="367"></a>    usePastTense = nil
<a name="368"></a>        
<a name="369"></a>    /*   
<a name="370"></a>     *   The AGAIN command could be interpreted in two different ways. It could
<a name="371"></a>     *   repeat the resolved action (using precisely the same objects as
<a name="372"></a>     *   before), or it could act as if the player had retyped the command and
<a name="373"></a>     *   then parse it again from scratch (which might result in a different
<a name="374"></a>     *   interpretation of the command, or different objects being selected).
<a name="375"></a>     *   The former interpretation is used if againRepeatsParse is nil; the
<a name="376"></a>     *   latter if it's true.
<a name="377"></a>     */    
<a name="378"></a>    againRepeatsParse = true
<a name="379"></a>    
<a name="380"></a>    /*   
<a name="381"></a>     *   Flag. If this is true the game attempts to switch the againRepeatsParse
<a name="382"></a>     *   flag between true and nil to give the contextually better
<a name="383"></a>     *   interpretation of AGAIN. This should be regarded as somewhat
<a name="384"></a>     *   experimental for now.
<a name="385"></a>     */
<a name="386"></a>    autoSwitchAgain = true    
<a name="387"></a>    
<a name="388"></a>    /* 
<a name="389"></a>     *   Is this game in verbose mode? By default we make it so, but players can
<a name="390"></a>     *   change this with the BRIEF/TERSE command.
<a name="391"></a>     */
<a name="392"></a>    verbose = true
<a name="393"></a>    
<a name="394"></a>    /* 
<a name="395"></a>     *   Is this game in fast GO TO mode? By default we make it not, so that the
<a name="396"></a>     *   GO TO command moves the player character only one step of the way at a
<a name="397"></a>     *   time, but if this is set to true the GO TO command will keep moving the
<a name="398"></a>     *   player until either the destination is reached or an obstacle is
<a name="399"></a>     *   encountered.
<a name="400"></a>     */
<a name="401"></a>    fastGoTo = nil
<a name="402"></a>      
<a name="403"></a>;
<a name="404"></a>
<a name="405"></a>/* ------------------------------------------------------------------------ */
<a name="406"></a>/*
<a name="407"></a> *   Clear the main game window.  In most cases, you should call this
<a name="408"></a> *   rather than calling the low-level clearScreen() function directly,
<a name="409"></a> *   since this routine takes care of a couple of chores that should
<a name="410"></a> *   usually be done at the same time.
<a name="411"></a> *   
<a name="412"></a> *   First, we flush the transcript to ensure that no left-over reports
<a name="413"></a> *   that were displayed before we cleared the screen will show up on the
<a name="414"></a> *   new screen.  Second, we call the low-level clearScreen() function to
<a name="415"></a> *   actually clear the display window.  Finally, we re-display any
<a name="416"></a> *   &lt;ABOUTBOX&gt; tag, to ensure that the about-box will still be around;
<a name="417"></a> *   this is necessary because any existing &lt;ABOUTBOX&gt; tag is lost after
<a name="418"></a> *   the screen is cleared.  
<a name="419"></a> */
<a name="420"></a>cls()
<a name="421"></a>{    /* clear the screen */
<a name="422"></a>    aioClearScreen();
<a name="423"></a>}
<a name="424"></a>
<a name="425"></a>
<a name="426"></a>
<a name="427"></a>
<a name="428"></a>/* ------------------------------------------------------------------------ */
<a name="429"></a>/*
<a name="430"></a> *   Determine if the given object overrides the definition of the given
<a name="431"></a> *   property inherited from the given base class.  Returns true if the
<a name="432"></a> *   object derives from the given base class, and the object's definition
<a name="433"></a> *   of the property comes from a different place than the base class's
<a name="434"></a> *   definition of the property.  
<a name="435"></a> */
<a name="436"></a>overrides(obj, base, prop)
<a name="437"></a>{
<a name="438"></a>    return (obj.ofKind(base)
<a name="439"></a>            &amp;&amp; (obj.propDefined(prop, PropDefGetClass)
<a name="440"></a>                != base.propDefined(prop, PropDefGetClass)));
<a name="441"></a>}
<a name="442"></a>
<a name="443"></a>/* ------------------------------------------------------------------------ */
<a name="444"></a>/*
<a name="445"></a> *   Library Pre-Initializer.  This object performs the following
<a name="446"></a> *   initialization operations immediately after compilation is completed:
<a name="447"></a> *   
<a name="448"></a> *   - adds each defined Thing to its container's contents list
<a name="449"></a> *   
<a name="450"></a> *   - adds each defined Sense to the global sense list
<a name="451"></a> *   
<a name="452"></a> *   This object is named so that other libraries and/or user code can
<a name="453"></a> *   create initialization order dependencies upon it.  
<a name="454"></a>// */
<a name="455"></a>adv3LibPreinit: PreinitObject
<a name="456"></a>    execute()
<a name="457"></a>    {
<a name="458"></a>
<a name="459"></a>        /* set the initial player character, as specified in gameMain */
<a name="460"></a>        gPlayerChar = gameMain.initialPlayerChar;
<a name="461"></a>        
<a name="462"></a>
<a name="463"></a>        
<a name="464"></a>
<a name="465"></a>        /* 
<a name="466"></a>         *   Attach the command sequencer output filter, the
<a name="467"></a>         *   language-specific message parameter substitution filter, the
<a name="468"></a>         *   style tag formatter filter, and the paragraph filter to the
<a name="469"></a>         *   main output stream.  Stack them so that the paragraph manager
<a name="470"></a>         *   is at the bottom, since the library tag filter can produce
<a name="471"></a>         *   paragraph tags and thus needs to sit atop the paragraph
<a name="472"></a>         *   filter.  Put the command sequencer above those, since it
<a name="473"></a>         *   might need to write style tags.  Finally, put the sense
<a name="474"></a>         *   context filter on top of those.  
<a name="475"></a>         */
<a name="476"></a>        mainOutputStream.addOutputFilter(typographicalOutputFilter);
<a name="477"></a>        mainOutputStream.addOutputFilter(mainParagraphManager);
<a name="478"></a>        mainOutputStream.addOutputFilter(styleTagFilter);        
<a name="479"></a>        mainOutputStream.addOutputFilter(cquoteOutputFilter);
<a name="480"></a>
<a name="481"></a>        mainOutputStream.addOutputFilter(commandSequencer);
<a name="482"></a>
<a name="483"></a>        /* 
<a name="484"></a>         *   Attach our message parameter filter and style tag filter to
<a name="485"></a>         *   the status line streams.  We don't need most of the main
<a name="486"></a>         *   window's filters in the status line.  
<a name="487"></a>         */
<a name="488"></a>        statusTagOutputStream.addOutputFilter(styleTagFilter);
<a name="489"></a>
<a name="490"></a>
<a name="491"></a>        statusLeftOutputStream.addOutputFilter(styleTagFilter);
<a name="492"></a>        statusLeftOutputStream.addOutputFilter(cquoteOutputFilter);
<a name="493"></a>        statusRightOutputStream.addOutputFilter(styleTagFilter);
<a name="494"></a>
<a name="495"></a>    }
<a name="496"></a>
<a name="497"></a>
<a name="498"></a>;
<a name="499"></a>//
<a name="500"></a>/* ------------------------------------------------------------------------ */
<a name="501"></a>/*
<a name="502"></a> *   Library Initializer.  This object performs the following
<a name="503"></a> *   initialization operations each time the game is started:
<a name="504"></a> *   
<a name="505"></a> *   - sets up the library's default output function 
<a name="506"></a> */
<a name="507"></a>adv3LibInit: InitObject
<a name="508"></a>    execute()
<a name="509"></a>    {
<a name="510"></a>        /* 
<a name="511"></a>         *   Set up our default output function.  Note that we must do
<a name="512"></a>         *   this during run-time initialization each time we start the
<a name="513"></a>         *   game, rather than during pre-initialization, because the
<a name="514"></a>         *   default output function state is not part of the load-image
<a name="515"></a>         *   configuration. 
<a name="516"></a>         */
<a name="517"></a>        t3SetSay(say);
<a name="518"></a>    }
<a name="519"></a>;
<a name="520"></a>
<a name="521"></a>
<a name="522"></a>/* ------------------------------------------------------------------------ */
<a name="523"></a>/*
<a name="524"></a> *   Generic script object.  This class can be used to implement a simple state
<a name="525"></a> *   machine.
<a name="526"></a> *
<a name="527"></a> *   We define Script in misc.t rather than eventList.t so that other parts of
<a name="528"></a> *   the library can safely test whether something is ofKind(Script) even it
<a name="529"></a> *   eventList.t is not present. The various types and subclasses of script are
<a name="530"></a> *   defined in eventList.t to allow them to be optionally excluded from the
<a name="531"></a> *   build if they're not needed in a particular game.
<a name="532"></a> */
<a name="533"></a>class Script: object
<a name="534"></a>    /* 
<a name="535"></a>     *   Get the current state.  This returns a value that gives the
<a name="536"></a>     *   current state of the script, which is usually simply an integer.  
<a name="537"></a>     */
<a name="538"></a>    getScriptState()
<a name="539"></a>    {
<a name="540"></a>        /* by default, return our state property */
<a name="541"></a>        return curScriptState;
<a name="542"></a>    }
<a name="543"></a>
<a name="544"></a>    /*
<a name="545"></a>     *   Process the next step of the script.  This routine must be
<a name="546"></a>     *   overridden to perform the action of the script.  This routine's
<a name="547"></a>     *   action should call getScriptState() to get our current state, and
<a name="548"></a>     *   should update the internal state appropriately to take us to the
<a name="549"></a>     *   next step after the current one.
<a name="550"></a>     *   
<a name="551"></a>     *   By default, we don't do anything at all.  
<a name="552"></a>     */
<a name="553"></a>    doScript()
<a name="554"></a>    {
<a name="555"></a>        /* override to carry out the script */
<a name="556"></a>    }
<a name="557"></a>
<a name="558"></a>    /* 
<a name="559"></a>     *   Property giving our current state.  This should never be used
<a name="560"></a>     *   directly; instead, getScriptState() should always be used, since
<a name="561"></a>     *   getScriptState() can be overridden so that the state depends on
<a name="562"></a>     *   something other than this internal state property. The meaning of
<a name="563"></a>     *   the state identifier is specific to each subclass.  
<a name="564"></a>     */
<a name="565"></a>    curScriptState = 0
<a name="566"></a>;
<a name="567"></a>/* ------------------------------------------------------------------------ */
<a name="568"></a>/*
<a name="569"></a> *   Library global variables 
<a name="570"></a> */
<a name="571"></a>libGlobal: object
<a name="572"></a>   
<a name="573"></a>    /*
<a name="574"></a>     *   The current library messages object.  This is the source object
<a name="575"></a>     *   for messages that don't logically relate to the actor carrying out
<a name="576"></a>     *   the comamand.  It's mostly used for meta-command replies, and for
<a name="577"></a>     *   text fragments that are used to construct descriptions.
<a name="578"></a>     *   
<a name="579"></a>     *   This message object isn't generally used for parser messages or
<a name="580"></a>     *   action replies - most of those come from the objects given by the
<a name="581"></a>     *   current actor's getParserMessageObj() or getActionMessageObj(),
<a name="582"></a>     *   respectively.
<a name="583"></a>     *   
<a name="584"></a>     *   By default, this is set to libMessages.  The library never changes
<a name="585"></a>     *   this itself, but a game can change this if it wants to switch to a
<a name="586"></a>     *   new set of messages during a game.  (If you don't need to change
<a name="587"></a>     *   messages during a game, but simply want to customize some of the
<a name="588"></a>     *   default messages, you don't need to set this variable - you can
<a name="589"></a>     *   simply use 'modify libMessages' instead.  This variable is
<a name="590"></a>     *   designed for cases where you want to *dynamically* change the
<a name="591"></a>     *   standard messages during the game.)  
<a name="592"></a>     */
<a name="593"></a>    libMessageObj = libMessages    
<a name="594"></a>   
<a name="595"></a>    /*
<a name="596"></a>     *   The current player character 
<a name="597"></a>     */
<a name="598"></a>    playerChar = nil   
<a name="599"></a>
<a name="600"></a>    /*   The name of the current player character */
<a name="601"></a>    playerCharName = nil
<a name="602"></a>    
<a name="603"></a>    /* 
<a name="604"></a>     *   The global score object.  We use a global for this, rather than
<a name="605"></a>     *   referencing libScore directly, to allow the score module to be
<a name="606"></a>     *   left out entirely if the game doesn't make use of scoring.  The
<a name="607"></a>     *   score module should set this during pre-initialization.  
<a name="608"></a>     */
<a name="609"></a>    scoreObj = nil
<a name="610"></a>
<a name="611"></a>    /* 
<a name="612"></a>     *   The global Footnote class object.  We use a global for this,
<a name="613"></a>     *   rather than referencing Footnote directly, to allow the footnote
<a name="614"></a>     *   module to be left out entirely if the game doesn't make use of
<a name="615"></a>     *   footnotes.  The footnote class should set this during
<a name="616"></a>     *   pre-initialization.  
<a name="617"></a>     */
<a name="618"></a>    footnoteClass = nil
<a name="619"></a>
<a name="620"></a>    /* the total number of turns so far */
<a name="621"></a>    totalTurns = 0
<a name="622"></a>
<a name="623"></a>    /* 
<a name="624"></a>     *   flag: the parser is in 'debug' mode, in which it displays the
<a name="625"></a>     *   parse tree for each command entered 
<a name="626"></a>     */
<a name="627"></a>    parserDebugMode = nil
<a name="628"></a>
<a name="629"></a>    /*
<a name="630"></a>     *   Most recent command, for 'undo' purposes.  This is the last
<a name="631"></a>     *   command the player character performed, or the last initial
<a name="632"></a>     *   command a player directed to an NPC.
<a name="633"></a>     *   
<a name="634"></a>     *   Note that if the player directed a series of commands to an NPC
<a name="635"></a>     *   with a single command line, only the first command on such a
<a name="636"></a>     *   command line is retained here, because it is only the first such
<a name="637"></a>     *   command that counts as a player's turn in terms of the game
<a name="638"></a>     *   clock.  Subsequent commands are executed by the NPC's on the
<a name="639"></a>     *   NPC's own time, and do not count against the PC's game clock
<a name="640"></a>     *   time.  The first command counts against the PC's clock because of
<a name="641"></a>     *   the time it takes the PC to give the command to the NPC.  
<a name="642"></a>     */
<a name="643"></a>    lastCommandForUndo = ''
<a name="644"></a>
<a name="645"></a>    /* 
<a name="646"></a>     *   Most recent target actor phrase; this goes with
<a name="647"></a>     *   lastCommandForUndo.  This is nil if the last command did not
<a name="648"></a>     *   specify an actor (i.e., was implicitly for the player character),
<a name="649"></a>     *   otherwise is the string the player typed specifying a target
<a name="650"></a>     *   actor.  
<a name="651"></a>     */
<a name="652"></a>    lastActorForUndo = ''
<a name="653"></a>    
<a name="654"></a>    /*   The text of the last command to be repeated by Again */    
<a name="655"></a>    lastCommandForAgain = ''
<a name="656"></a>
<a name="657"></a>    /*
<a name="658"></a>     *   Current command information.  We keep track of the current
<a name="659"></a>     *   command's actor and action here.  
<a name="660"></a>     */
<a name="661"></a>    curActor = nil
<a name="662"></a>    curIssuingActor = nil
<a name="663"></a>    curAction = nil
<a name="664"></a>    
<a name="665"></a>    /* The current Command object */
<a name="666"></a>    curCommand = nil
<a name="667"></a>
<a name="668"></a>    /* The last action to be performed. */
<a name="669"></a>    lastAction = nil
<a name="670"></a>    
<a name="671"></a>    /* The previous Command object */
<a name="672"></a>    lastCommand = nil
<a name="673"></a>    
<a name="674"></a>    /* the exitLister object, if included in the build */
<a name="675"></a>    exitListerObj = nil
<a name="676"></a>
<a name="677"></a>    /* the hint manager, if included in the build */
<a name="678"></a>    hintManagerObj = nil
<a name="679"></a>    
<a name="680"></a>    /* the extra hint manager, if included in the build */
<a name="681"></a>    extraHintManagerObj = nil
<a name="682"></a>
<a name="683"></a>    /*
<a name="684"></a>     *   The game's IFID, as defined in the game's main module ID object.
<a name="685"></a>     *   If the game has multiple IFIDs in the module list, this will store
<a name="686"></a>     *   only the first IFID in the list.  NOTE: the library initializes
<a name="687"></a>     *   this automatically during preinit; don't set this manually.  
<a name="688"></a>     */
<a name="689"></a>    IFID = nil
<a name="690"></a>
<a name="691"></a>    /*
<a name="692"></a>     *   Command line arguments.  The library sets this to a list of
<a name="693"></a>     *   strings containing the arguments passed to the program on the
<a name="694"></a>     *   command line.  This list contains the command line arguments
<a name="695"></a>     *   parsed according to the local conventions for the operating system
<a name="696"></a>     *   and C++ library.  The standard parsing procedure used by most
<a name="697"></a>     *   systems is to break the line into tokens delimited by space
<a name="698"></a>     *   characters.  Many systems also allow space characters to be
<a name="699"></a>     *   embedded in tokens by quoting the tokens.  The first argument is
<a name="700"></a>     *   always the name of the .t3 file currently executing.  
<a name="701"></a>     */
<a name="702"></a>    commandLineArgs = []
<a name="703"></a>
<a name="704"></a>    /*
<a name="705"></a>     *   Retrieve a "switch" from the command line.  Switches are options
<a name="706"></a>     *   specifies with the conventional Unix "-xxx" notation.  This
<a name="707"></a>     *   searches for a command option that equals the given string or
<a name="708"></a>     *   starts with the given substring.  If we find it, we return the
<a name="709"></a>     *   part of the option after the given substring - this is
<a name="710"></a>     *   conventionally the value of the switch.  For example, the command
<a name="711"></a>     *   line might look like this:
<a name="712"></a>     *   
<a name="713"></a>     *.    t3run mygame.t3 -name=MyGame -user=Bob
<a name="714"></a>     *   
<a name="715"></a>     *   Searching for '-name=' would return 'MyGame', and searching for
<a name="716"></a>     *   '-user=' would return' Bob'.
<a name="717"></a>     *   
<a name="718"></a>     *   If the switch is found but has no value attached, the return value
<a name="719"></a>     *   is an empty string.  If the switch isn't found at all, the return
<a name="720"></a>     *   value is nil.  
<a name="721"></a>     */
<a name="722"></a>    getCommandSwitch(s)
<a name="723"></a>    {
<a name="724"></a>        /* search from argument 2 to the last switch argument */
<a name="725"></a>        local args = commandLineArgs;
<a name="726"></a>        for (local i in 2..args.length())
<a name="727"></a>        {
<a name="728"></a>            /* 
<a name="729"></a>             *   if this isn't a switch, or is the special "-" last switch
<a name="730"></a>             *   marker, we're done
<a name="731"></a>             */
<a name="732"></a>            local a = args[i];
<a name="733"></a>            if (!a.startsWith('-') || a == '-')
<a name="734"></a>                return nil;
<a name="735"></a>
<a name="736"></a>            /* check for a match */
<a name="737"></a>            if (a.startsWith(s))
<a name="738"></a>                return a.substr(s.length() + 1);
<a name="739"></a>        }
<a name="740"></a>
<a name="741"></a>        /* didn't find it */
<a name="742"></a>        return nil;
<a name="743"></a>    }
<a name="744"></a>
<a name="745"></a>    /* 
<a name="746"></a>     *   The last location visited by the player char before a travel action.
<a name="747"></a>     *   Noted to allow travel back.
<a name="748"></a>     */    
<a name="749"></a>    lastLoc = nil
<a name="750"></a>    
<a name="751"></a>   
<a name="752"></a>    /* 
<a name="753"></a>     *   A lookup table to store information about the destinations of direction
<a name="754"></a>     *   properties not connected to objects (i.e. direction properties defined
<a name="755"></a>     *   as strings or methods
<a name="756"></a>     */    
<a name="757"></a>    extraDestInfo = static [ * -&gt; unknownDest_ ]
<a name="758"></a>
<a name="759"></a>    /* 
<a name="760"></a>     *   Add an item to the extraDestInfo table keyed on the source room plus
<a name="761"></a>     *   the direction taken, with the value being the destination arrived at
<a name="762"></a>     *   (which most of the time will probably be the same as the source, since
<a name="763"></a>     *   in most cases where we create one of these records, no travel will have
<a name="764"></a>     *   taken place.
<a name="765"></a>     */    
<a name="766"></a>    addExtraDestInfo(source, dirn, dest)
<a name="767"></a>    {
<a name="768"></a>        if(extraDestInfo == nil)
<a name="769"></a>            extraDestInfo = [ * -&gt; unknownDest_ ];
<a name="770"></a>        
<a name="771"></a>        /* 
<a name="772"></a>         *   Record the extra dest info in the extraDestInfo table unless it's
<a name="773"></a>         *   already set to nil, which is a signal that we don't want the
<a name="774"></a>         *   pathfinder or other code to use this information.
<a name="775"></a>         */
<a name="776"></a>        
<a name="777"></a>        if(extraDestInfo[[source, dirn]] not in (nil, varDest_))
<a name="778"></a>           extraDestInfo[[source, dirn]] = dest;
<a name="779"></a>            
<a name="780"></a>    }
<a name="781"></a>    
<a name="782"></a>    /*
<a name="783"></a>     *   Mark a tag as revealed.  This adds an entry for the tag to the
<a name="784"></a>     *   revealedNameTab table.  We simply set the table entry to 'true'; the
<a name="785"></a>     *   presence of the tag in the table constitutes the indication that the
<a name="786"></a>     *   tag has been revealed.
<a name="787"></a>     *
<a name="788"></a>     *   (Games and library extensions can use 'modify' to override this and
<a name="789"></a>     *   store more information in the table entry.  For example, you could
<a name="790"></a>     *   store the time when the information was first revealed, or the location
<a name="791"></a>     *   where it was learned.  If you do override this, just be sure to set the
<a name="792"></a>     *   revealedNameTab entry for the tag to a non-nil and non-zero value, so
<a name="793"></a>     *   that any code testing the presence of the table entry will see that the
<a name="794"></a>     *   slot is indeed set.)
<a name="795"></a>     *
<a name="796"></a>     *   We put the revealedNameTab table and the setRevealed method here rather
<a name="797"></a>     *   than on conversationManager so that it's available to games that don't
<a name="798"></a>     *   include actor.t.
<a name="799"></a>     */
<a name="800"></a>    setRevealed(tag)
<a name="801"></a>    {
<a name="802"></a>        revealedNameTab[tag] = true;
<a name="803"></a>    }
<a name="804"></a>
<a name="805"></a>    /*
<a name="806"></a>     *   Mark a tag as unrevealed.  This removes the entry for the tag from the
<a name="807"></a>     *   revealedNameTab table.  
<a name="808"></a>     *
<a name="809"></a>     *   We put the revealedNameTab table and the setRevealed method here rather
<a name="810"></a>     *   than on conversationManager so that it's available to games that don't
<a name="811"></a>     *   include actor.t.
<a name="812"></a>     */
<a name="813"></a>    setUnrevealed(tag)
<a name="814"></a>    {
<a name="815"></a>        revealedNameTab.removeElement(tag);
<a name="816"></a>    }
<a name="817"></a>    
<a name="818"></a>    
<a name="819"></a>    /* 
<a name="820"></a>     *   The global lookup table of all revealed keys.  This table is keyed
<a name="821"></a>     *   by the string naming the revelation; the value associated with
<a name="822"></a>     *   each key is not used (we always just set it to true).  
<a name="823"></a>     */
<a name="824"></a>    revealedNameTab = static new LookupTable(32, 32)
<a name="825"></a>    
<a name="826"></a>    /*  
<a name="827"></a>     *   The symbol table for every game object.
<a name="828"></a>     */    
<a name="829"></a>    objectNameTab = nil
<a name="830"></a> 
<a name="831"></a>    /* The thought manager object, if it exists. */    
<a name="832"></a>    thoughtManagerObj = nil
<a name="833"></a>    
<a name="834"></a>    /* The object last written on */
<a name="835"></a>    lastWrittenOnObj = nil
<a name="836"></a>       
<a name="837"></a>    /* The object last typed on */
<a name="838"></a>    lastTypedOnObj = nil
<a name="839"></a>    
<a name="840"></a>    /* 
<a name="841"></a>     *   our name table for parameter substitutions - a LookupTable that we set
<a name="842"></a>     *   up during preinit
<a name="843"></a>     */
<a name="844"></a>    nameTable_ = static new LookupTable()  
<a name="845"></a>    
<a name="846"></a>    /* 
<a name="847"></a>     *   Flag determining whether inventory listing should be in the wide (nil) or tall (true)
<a name="848"></a>     *   format. By default we start out with the wide format (inventoryTall = nil), although game
<a name="849"></a>     *   code could override this.
<a name="850"></a>     */
<a name="851"></a>    inventoryTall = nil     
<a name="852"></a>;
<a name="853"></a>
<a name="854"></a>
<a name="855"></a>
<a name="856"></a>/* object representing an unknown destination */
<a name="857"></a>unknownDest_: Room 'unknown'
<a name="858"></a>;
<a name="859"></a>
<a name="860"></a>
<a name="861"></a>/* object representing a variable destination */
<a name="862"></a>varDest_: Room 'unknown'
<a name="863"></a>;
<a name="864"></a>
<a name="865"></a>/* ------------------------------------------------------------------------ */
<a name="866"></a>/*
<a name="867"></a> *   FinishType objects are used in finishGameMsg() to indicate what kind
<a name="868"></a> *   of game-over message to display.  We provide a couple of standard
<a name="869"></a> *   objects for the most common cases. 
<a name="870"></a> */
<a name="871"></a>class FinishType: object
<a name="872"></a>    /* the finishing message, as a string or library message property */
<a name="873"></a>    finishMsg = nil
<a name="874"></a>;
<a name="875"></a>
<a name="876"></a>/* 'death' - the game has ended due to the player character's demise */
<a name="877"></a>ftDeath: FinishType finishMsg = BMsg(finish death, 'YOU HAVE DIED');
<a name="878"></a>
<a name="879"></a>/* 'victory' - the player has won the game */
<a name="880"></a>ftVictory: FinishType finishMsg = BMsg(finish victory,'YOU HAVE WON');
<a name="881"></a>
<a name="882"></a>/* 'failure' - the game has ended in failure (but not necessarily death) */
<a name="883"></a>ftFailure: FinishType finishMsg = BMsg(finish failure, 'YOU HAVE FAILED');
<a name="884"></a>
<a name="885"></a>/* 'game over' - the game has simply ended */
<a name="886"></a>ftGameOver: FinishType finishMsg = BMsg(finish game over, 'GAME OVER');
<a name="887"></a>
<a name="888"></a>/*
<a name="889"></a> *   Finish the game, showing a message explaining why the game has ended.
<a name="890"></a> *   This can be called when an event occurs that ends the game, such as
<a name="891"></a> *   the player character's death, winning, or any other endpoint in the
<a name="892"></a> *   story.
<a name="893"></a> *   
<a name="894"></a> *   We'll show a message defined by 'msg', using a standard format.  The
<a name="895"></a> *   format depends on the language, but in English, it's usually the
<a name="896"></a> *   message surrounded by asterisks: "*** You have won! ***".  'msg' can
<a name="897"></a> *   be:
<a name="898"></a> *   
<a name="899"></a> *.    - nil, in which case we display nothing
<a name="900"></a> *.    - a string, which we'll display as the message
<a name="901"></a> *.    - a FinishType object, from which we'll get the message
<a name="902"></a> *   
<a name="903"></a> *   After showing the message (if any), we'll prompt the user with
<a name="904"></a> *   options for how to proceed.  We'll always show the QUIT, RESTART, and
<a name="905"></a> *   RESTORE options; other options can be offered by listing one or more
<a name="906"></a> *   FinishOption objects in the 'extra' parameter, which is given as a
<a name="907"></a> *   list of FinishOption objects.  The library defines a few non-default
<a name="908"></a> *   finish options, such as finishOptionUndo and finishOptionCredits; in
<a name="909"></a> *   addition, the game can subclass FinishOption to create its own custom
<a name="910"></a> *   options, as desired.  
<a name="911"></a> */
<a name="912"></a>finishGameMsg(msg, extra)
<a name="913"></a>{
<a name="914"></a>    local lst;
<a name="915"></a>
<a name="916"></a>    
<a name="917"></a>    /*
<a name="918"></a>     *   Explicitly run any final score notification now.  This will ensure
<a name="919"></a>     *   that any points awarded in the course of the final command that
<a name="920"></a>     *   brought us to this point will generate the usual notification, and
<a name="921"></a>     *   that the notification will appear at a reasonable place, just
<a name="922"></a>     *   before the termination message. 
<a name="923"></a>     */
<a name="924"></a>    if (libGlobal.scoreObj != nil)
<a name="925"></a>    {
<a name="926"></a>        "&lt;.p&gt;";
<a name="927"></a>        libGlobal.scoreObj.runScoreNotifier();
<a name="928"></a>    }
<a name="929"></a>
<a name="930"></a>    /* translate the message, if specified */
<a name="931"></a>    if (dataType(msg) == TypeObject)
<a name="932"></a>    {
<a name="933"></a>        /* it's a FinishType object - get its message property or string */
<a name="934"></a>        msg = msg.finishMsg;
<a name="935"></a>
<a name="936"></a>        /* if it's a library message property, look it up */
<a name="937"></a>        if (dataType(msg) == TypeProp)
<a name="938"></a>            msg = gLibMessages.(msg);
<a name="939"></a>    }
<a name="940"></a>
<a name="941"></a>    /* if we have a message, display it */
<a name="942"></a>    if (msg != nil)
<a name="943"></a>        DMsg(show finish msg, '\b*** {1} ***\b\b', msg);
<a name="944"></a>        
<a name="945"></a>
<a name="946"></a>    /* if the extra options include a scoring option, show the score */
<a name="947"></a>    if (extra != nil &amp;&amp; extra.indexWhich({x: x.showScoreInFinish}) != nil)
<a name="948"></a>    {
<a name="949"></a>        "&lt;.p&gt;";
<a name="950"></a>        libGlobal.scoreObj.showScore();
<a name="951"></a>        "&lt;.p&gt;";
<a name="952"></a>    }
<a name="953"></a>    gActor = gPlayerChar;
<a name="954"></a>
<a name="955"></a>    /* start with the standard options */
<a name="956"></a>    lst = [finishOptionRestore, finishOptionRestart];
<a name="957"></a>
<a name="958"></a>    /* add any additional options in the 'extra' parameter */
<a name="959"></a>    if (extra != nil)
<a name="960"></a>        lst += extra;
<a name="961"></a>
<a name="962"></a>    /* always add 'quit' as the last option */
<a name="963"></a>    lst += finishOptionQuit;
<a name="964"></a>
<a name="965"></a>    /* process the options */
<a name="966"></a>    processOptions(lst);
<a name="967"></a>}
<a name="968"></a>
<a name="969"></a>/* finish the game, offering the given extra options but no message */
<a name="970"></a>finishGame(extra)
<a name="971"></a>{
<a name="972"></a>    finishGameMsg(nil, extra);
<a name="973"></a>}
<a name="974"></a>
<a name="975"></a>/*
<a name="976"></a> *   Show failed startup restore options.  If a restore operation fails at
<a name="977"></a> *   startup, we won't just proceed with the game, but ask the user what
<a name="978"></a> *   they want to do; we'll offer the options of restoring another game,
<a name="979"></a> *   quitting, or starting the game from the beginning.  
<a name="980"></a> */
<a name="981"></a>failedRestoreOptions()
<a name="982"></a>{
<a name="983"></a>    /* process our set of options */
<a name="984"></a>    processOptions([restoreOptionRestoreAnother, restoreOptionStartOver,
<a name="985"></a>                    finishOptionQuit]);
<a name="986"></a>}
<a name="987"></a>
<a name="988"></a>/*
<a name="989"></a> *   Process a list of finishing options.  We'll loop, showing prompts and
<a name="990"></a> *   reading responses, until we get a response that terminates the loop.  
<a name="991"></a> */
<a name="992"></a>processOptions(lst)
<a name="993"></a>{
<a name="994"></a>    /* keep going until we get a valid response */
<a name="995"></a>promptLoop:
<a name="996"></a>    for (;;)
<a name="997"></a>    {
<a name="998"></a>        local resp;
<a name="999"></a>        
<a name="1000"></a>        /* show the options */
<a name="1001"></a>        finishOptionsLister.show(lst, 0);
<a name="1002"></a>
<a name="1003"></a>        /* 
<a name="1004"></a>         *   update the status line, in case the score or turn counter has
<a name="1005"></a>         *   changed (this is especially likely when we first enter this
<a name="1006"></a>         *   loop, since we might have just finished the game with our
<a name="1007"></a>         *   previous action, and that action might well have awarded us
<a name="1008"></a>         *   some points) 
<a name="1009"></a>         */
<a name="1010"></a>        statusLine.showStatusLine();
<a name="1011"></a>
<a name="1012"></a>        /* read a response */       
<a name="1013"></a>        "&gt;";
<a name="1014"></a>        resp = inputManager.getInputLine();
<a name="1015"></a>
<a name="1016"></a>
<a name="1017"></a>        /* check for a match to each of the options in our list */
<a name="1018"></a>        foreach (local cur in lst)
<a name="1019"></a>        {
<a name="1020"></a>            /* if this one matches, process the option */
<a name="1021"></a>            if (cur.responseMatches(resp))
<a name="1022"></a>            {
<a name="1023"></a>                /* it matches - carry out the option */
<a name="1024"></a>                if (cur.doOption())
<a name="1025"></a>                {
<a name="1026"></a>                    /* 
<a name="1027"></a>                     *   they returned true - they want to continue asking
<a name="1028"></a>                     *   for more options
<a name="1029"></a>                     */
<a name="1030"></a>                    continue promptLoop;
<a name="1031"></a>                }
<a name="1032"></a>                else
<a name="1033"></a>                {
<a name="1034"></a>                    /* 
<a name="1035"></a>                     *   they returned nil - they want us to stop asking
<a name="1036"></a>                     *   for options and return to our caller 
<a name="1037"></a>                     */
<a name="1038"></a>                    return;
<a name="1039"></a>                }
<a name="1040"></a>            }
<a name="1041"></a>        }
<a name="1042"></a>
<a name="1043"></a>        /*
<a name="1044"></a>         *   If we got this far, it means that we didn't get a valid
<a name="1045"></a>         *   option.  Display our "invalid option" message, and continue
<a name="1046"></a>         *   looping so that we show the prompt again and read a new
<a name="1047"></a>         *   option.  
<a name="1048"></a>         */       
<a name="1049"></a>        DMsg(invalid finish option, '&lt;q&gt;{1}&lt;/q&gt; was not one of the
<a name="1050"></a>            options.&lt;.p&gt;', resp);
<a name="1051"></a>    }
<a name="1052"></a>}
<a name="1053"></a>
<a name="1054"></a>/*
<a name="1055"></a> *   Finish Option class.  This is the base class for the abstract objects
<a name="1056"></a> *   representing options offered by finishGame.  
<a name="1057"></a> */
<a name="1058"></a>class FinishOption: object
<a name="1059"></a>    /* 
<a name="1060"></a>     *   The description, as displayed in the list of options.  For the
<a name="1061"></a>     *   default English messages, this is expected to be a verb phrase in
<a name="1062"></a>     *   infinitive form, and should show the keyword accepted as a
<a name="1063"></a>     *   response in all capitals: "RESTART", "see some AMUSING things to
<a name="1064"></a>     *   do", "show CREDITS". 
<a name="1065"></a>     */
<a name="1066"></a>    desc = ""
<a name="1067"></a>
<a name="1068"></a>    /* 
<a name="1069"></a>     *   By default, the item is listed.  If you want to create an
<a name="1070"></a>     *   invisible option that's accepted but which isn't listed in the
<a name="1071"></a>     *   prompt, just set this to nil.  Invisible options are sometimes
<a name="1072"></a>     *   useful when the output of one option mentions another option; for
<a name="1073"></a>     *   example, the CREDITS message might mention a LICENSE command for
<a name="1074"></a>     *   displaying the license, so you want to make that command available
<a name="1075"></a>     *   without cluttering the prompt with it.  
<a name="1076"></a>     */
<a name="1077"></a>    listed = true
<a name="1078"></a>
<a name="1079"></a>    /* our response keyword */
<a name="1080"></a>    responseKeyword = ''
<a name="1081"></a>
<a name="1082"></a>    /* 
<a name="1083"></a>     *   a single character we accept as an alternative to our full
<a name="1084"></a>     *   response keyword, or nil if we don't accept a single-character
<a name="1085"></a>     *   response 
<a name="1086"></a>     */
<a name="1087"></a>    responseChar = nil
<a name="1088"></a>    
<a name="1089"></a>    /* 
<a name="1090"></a>     *   Match a response string to this option.  Returns true if the
<a name="1091"></a>     *   string matches our response, nil otherwise.  By default, we'll
<a name="1092"></a>     *   return true if the string exactly matches responseKeyword or
<a name="1093"></a>     *   exactly matches our responseChar (if that's non-nil), but this
<a name="1094"></a>     *   can be overridden to match other strings if desired.  By default,
<a name="1095"></a>     *   we'll match the response without regard to case.
<a name="1096"></a>     */
<a name="1097"></a>    responseMatches(response)
<a name="1098"></a>    {
<a name="1099"></a>        /* do all of our work in lower-case */
<a name="1100"></a>        response = response.toLower();
<a name="1101"></a>
<a name="1102"></a>        /* 
<a name="1103"></a>         *   check for a match the full response keyword or to the single
<a name="1104"></a>         *   response character 
<a name="1105"></a>         */
<a name="1106"></a>        return (response == responseKeyword.toLower()
<a name="1107"></a>                || (responseChar != nil
<a name="1108"></a>                    &amp;&amp; response == responseChar.toLower()));
<a name="1109"></a>    }
<a name="1110"></a>
<a name="1111"></a>    /*
<a name="1112"></a>     *   Carry out the option.  This is called when the player enters a
<a name="1113"></a>     *   response that matches this option.  This routine must perform the
<a name="1114"></a>     *   action of the option, then return true to indicate that we should
<a name="1115"></a>     *   ask for another option, or nil to indicate that the finishGame()
<a name="1116"></a>     *   routine should simply return.  
<a name="1117"></a>     */
<a name="1118"></a>    doOption()
<a name="1119"></a>    {
<a name="1120"></a>        /* tell finishGame() to ask for another option */
<a name="1121"></a>        return true;
<a name="1122"></a>    }
<a name="1123"></a>
<a name="1124"></a>    /* 
<a name="1125"></a>     *   Flag: show the score with the end-of-game announcement.  If any
<a name="1126"></a>     *   option in the list of finishing options has this flag set, we'll
<a name="1127"></a>     *   show the score using the same message that the SCORE command
<a name="1128"></a>     *   uses. 
<a name="1129"></a>     */
<a name="1130"></a>    showScoreInFinish = nil
<a name="1131"></a>;
<a name="1132"></a>
<a name="1133"></a>/*
<a name="1134"></a> *   QUIT option for finishGame.  The language-specific code should modify
<a name="1135"></a> *   this to specify the description and response keywords.  
<a name="1136"></a> */
<a name="1137"></a>finishOptionQuit: FinishOption
<a name="1138"></a>    doOption()
<a name="1139"></a>    {
<a name="1140"></a>        /* 
<a name="1141"></a>         *   carry out the Quit action - this will signal a
<a name="1142"></a>         *   QuittingException, so this call will never return 
<a name="1143"></a>         */
<a name="1144"></a>        throw new QuittingException;
<a name="1145"></a>    }
<a name="1146"></a>    listOrder = 100
<a name="1147"></a>    
<a name="1148"></a>;
<a name="1149"></a>
<a name="1150"></a>/*
<a name="1151"></a> *   RESTORE option for finishGame. 
<a name="1152"></a> */
<a name="1153"></a>finishOptionRestore: FinishOption
<a name="1154"></a>    doOption()
<a name="1155"></a>    {
<a name="1156"></a>        /* 
<a name="1157"></a>         *   Try restoring.  If this succeeds (i.e., it returns true), tell
<a name="1158"></a>         *   the caller to stop looping and to proceed with the game by
<a name="1159"></a>         *   returning nil.  If this fails, tell the caller to keep looping
<a name="1160"></a>         *   by returning true.
<a name="1161"></a>         */
<a name="1162"></a>        if (Restore.askAndRestore())
<a name="1163"></a>        {
<a name="1164"></a>            /* 
<a name="1165"></a>             *   we succeeded, so we're now restored to some prior game
<a name="1166"></a>             *   state - terminate any remaining processing in the command
<a name="1167"></a>             *   that triggered the end-of-game options
<a name="1168"></a>             */
<a name="1169"></a>
<a name="1170"></a>            abort;
<a name="1171"></a>        }
<a name="1172"></a>        else
<a name="1173"></a>        {
<a name="1174"></a>            /* it failed - tell the caller to keep looping */
<a name="1175"></a>            return true;
<a name="1176"></a>        }
<a name="1177"></a>    }
<a name="1178"></a>    
<a name="1179"></a>    listOrder = 90
<a name="1180"></a>;
<a name="1181"></a>
<a name="1182"></a>/*
<a name="1183"></a> *   RESTART option for finishGame 
<a name="1184"></a> */
<a name="1185"></a>finishOptionRestart: FinishOption
<a name="1186"></a>    doOption()
<a name="1187"></a>    {
<a name="1188"></a>        /* 
<a name="1189"></a>         *   carry out the restart - this will not return, since we'll
<a name="1190"></a>         *   reset the game state and re-enter the game at the restart
<a name="1191"></a>         *   entrypoint 
<a name="1192"></a>         */
<a name="1193"></a>        Restart.doRestartGame();
<a name="1194"></a>    }
<a name="1195"></a>    
<a name="1196"></a>   listOrder = 10
<a name="1197"></a>;
<a name="1198"></a>
<a name="1199"></a>/*
<a name="1200"></a> *   START FROM BEGINNING option for failed startup restore.  This is just
<a name="1201"></a> *   like finishOptionRestart, but shows a different option name.  
<a name="1202"></a> */
<a name="1203"></a>restoreOptionStartOver: finishOptionRestart
<a name="1204"></a>;
<a name="1205"></a>
<a name="1206"></a>/* 
<a name="1207"></a> *   RESTORE ANOTHER GAME option for failed startup restore.  This is just
<a name="1208"></a> *   like finishOptionRestore, but shows a different option name. 
<a name="1209"></a> */
<a name="1210"></a>restoreOptionRestoreAnother: finishOptionRestore
<a name="1211"></a>;
<a name="1212"></a>
<a name="1213"></a>/*
<a name="1214"></a> *   UNDO option for finishGame 
<a name="1215"></a> */
<a name="1216"></a>finishOptionUndo: FinishOption
<a name="1217"></a>    doOption()
<a name="1218"></a>    {
<a name="1219"></a>        /* try performing the undo */
<a name="1220"></a>        if (Undo.execAction(nil))
<a name="1221"></a>        {
<a name="1222"></a>            
<a name="1223"></a>            
<a name="1224"></a>            gPlayerChar.outermostVisibleParent().lookAroundWithin();
<a name="1225"></a>            
<a name="1226"></a>            
<a name="1227"></a>            /* 
<a name="1228"></a>             *   Success - terminate the current command with no further
<a name="1229"></a>             *   processing.
<a name="1230"></a>             */
<a name="1231"></a>            throw new TerminateCommandException();
<a name="1232"></a>        }
<a name="1233"></a>        else
<a name="1234"></a>        {
<a name="1235"></a>            /* 
<a name="1236"></a>             *   failure - show a blank line and tell the caller to ask
<a name="1237"></a>             *   for another option, since we couldn't carry out this
<a name="1238"></a>             *   option 
<a name="1239"></a>             */
<a name="1240"></a>            "&lt;.p&gt;";
<a name="1241"></a>            return true;
<a name="1242"></a>        }
<a name="1243"></a>    }
<a name="1244"></a>    listOrder = 20
<a name="1245"></a>;
<a name="1246"></a>
<a name="1247"></a>/*
<a name="1248"></a> *   FULL SCORE option for finishGame
<a name="1249"></a> */
<a name="1250"></a>finishOptionFullScore: FinishOption
<a name="1251"></a>    doOption()
<a name="1252"></a>    {
<a name="1253"></a>        /* show a blank line before the score display */
<a name="1254"></a>        "\b";
<a name="1255"></a>
<a name="1256"></a>        /* run the Full Score action */
<a name="1257"></a>        FullScore.showFullScore();
<a name="1258"></a>
<a name="1259"></a>        /* show a paragraph break after the score display */
<a name="1260"></a>        "&lt;.p&gt;";
<a name="1261"></a>
<a name="1262"></a>        /* 
<a name="1263"></a>         *   this option has now had its full effect, so tell the caller
<a name="1264"></a>         *   to go back and ask for a new option 
<a name="1265"></a>         */
<a name="1266"></a>        return true;
<a name="1267"></a>    }
<a name="1268"></a>
<a name="1269"></a>    /* 
<a name="1270"></a>     *   by default, show the score with the end-of-game announcement when
<a name="1271"></a>     *   this option is included 
<a name="1272"></a>     */
<a name="1273"></a>    showScoreInFinish = true
<a name="1274"></a>    listOrder = 30
<a name="1275"></a>   
<a name="1276"></a>;
<a name="1277"></a>
<a name="1278"></a>/*
<a name="1279"></a> *   Option to show the score in finishGame.  This doesn't create a listed
<a name="1280"></a> *   option in the set of offered options, but rather is simply a flag to
<a name="1281"></a> *   finishGame() that the score should be announced along with the
<a name="1282"></a> *   end-of-game announcement message. 
<a name="1283"></a> */
<a name="1284"></a>finishOptionScore: FinishOption
<a name="1285"></a>    /* show the score in the end-of-game announcement */
<a name="1286"></a>    showScoreInFinish = true
<a name="1287"></a>
<a name="1288"></a>    /* this is not a listed option */
<a name="1289"></a>    listed = nil
<a name="1290"></a>
<a name="1291"></a>    /* this option isn't selectable, so it has no effect */
<a name="1292"></a>    doOption() { }
<a name="1293"></a>    
<a name="1294"></a>    listOrder = 40
<a name="1295"></a>;
<a name="1296"></a>
<a name="1297"></a>/*
<a name="1298"></a> *   CREDITS option for finishGame 
<a name="1299"></a> */
<a name="1300"></a>finishOptionCredits: FinishOption
<a name="1301"></a>    doOption()
<a name="1302"></a>    {
<a name="1303"></a>        /* show a blank line before the credits */
<a name="1304"></a>        "\b";
<a name="1305"></a>
<a name="1306"></a>        /* run the Credits action */
<a name="1307"></a>        versionInfo.showCredit();
<a name="1308"></a>
<a name="1309"></a>        /* show a paragraph break after the credits */
<a name="1310"></a>        "&lt;.p&gt;";
<a name="1311"></a>
<a name="1312"></a>        /* 
<a name="1313"></a>         *   this option has now had its full effect, so tell the caller
<a name="1314"></a>         *   to go back and ask for a new option 
<a name="1315"></a>         */
<a name="1316"></a>        return true;
<a name="1317"></a>    }
<a name="1318"></a>    
<a name="1319"></a>    listOrder = 50
<a name="1320"></a>;  
<a name="1321"></a>
<a name="1322"></a>/*
<a name="1323"></a> *   AMUSING option for finishGame 
<a name="1324"></a> */
<a name="1325"></a>finishOptionAmusing: FinishOption
<a name="1326"></a>    /*
<a name="1327"></a>     *   The game must modify this object to define a doOption method.  We
<a name="1328"></a>     *   have no built-in way to show a list of amusing things to try, so
<a name="1329"></a>     *   if a game wants to offer this option, it must provide a suitable
<a name="1330"></a>     *   definition here.  (We never offer this option by default, so a
<a name="1331"></a>     *   game need not provide a definition if the game doesn't explicitly
<a name="1332"></a>     *   offer this option via the 'extra' argument to finishGame()).  
<a name="1333"></a>     */
<a name="1334"></a>   listOrder = 60
<a name="1335"></a>;
<a name="1336"></a>
<a name="1337"></a>
<a name="1338"></a>/* -------------------------------------------------------------------------- */
<a name="1339"></a>/*
<a name="1340"></a> *   Utility functions 
<a name="1341"></a> */
<a name="1342"></a>
<a name="1343"></a>/* 
<a name="1344"></a> *   Try converting val to an integer. If this results in an integer value,
<a name="1345"></a> *   return it, otherwise return nil.
<a name="1346"></a> */
<a name="1347"></a>
<a name="1348"></a>tryInt(val)
<a name="1349"></a>{
<a name="1350"></a>    /* 
<a name="1351"></a>     *   If the value passed to the function is neither an integer nor a string
<a name="1352"></a>     *   nor a BigNumber, return nil, since there can be no valid integer
<a name="1353"></a>     *   representation of it.
<a name="1354"></a>     */    
<a name="1355"></a>    if(dataType(val) not in (TypeInt, TypeSString, TypeObject)
<a name="1356"></a>       || (dataType(val) == TypeObject &amp;&amp; !(val.ofKind(BigNumber))))
<a name="1357"></a>        return nil;
<a name="1358"></a>    
<a name="1359"></a>    /* Try converting val to an integer. */
<a name="1360"></a>    local res = toInteger(val);
<a name="1361"></a>   
<a name="1362"></a>    /*   
<a name="1363"></a>     *   If val is a string then res is a valid number if val is a string that
<a name="1364"></a>     *   contains one or more zeroes perhaps preceded by + or -.
<a name="1365"></a>     */
<a name="1366"></a>    
<a name="1367"></a>    if(dataType(val) == TypeSString)    
<a name="1368"></a>    {
<a name="1369"></a>        /* 
<a name="1370"></a>         *   Strip out all the spaces from val.         
<a name="1371"></a>         */
<a name="1372"></a>        val = val.findReplace(' ', '').trim();
<a name="1373"></a>        
<a name="1374"></a>        if(val.match(R'(&lt;plus&gt;|-)?&lt;digit&gt;+$'))
<a name="1375"></a>            return res;       
<a name="1376"></a>        
<a name="1377"></a>    }
<a name="1378"></a>    
<a name="1379"></a>       
<a name="1380"></a>    /* 
<a name="1381"></a>     *   If val is a BigNumber or an integer, this is also a valid result, so
<a name="1382"></a>     *   return it. Note that we need only test for whether val is an object,
<a name="1383"></a>     *   since if it was any other kind of object than a BigNumber, this
<a name="1384"></a>     *   function would have returned nil at the first test.
<a name="1385"></a>     */     
<a name="1386"></a>    if(dataType(val) is in (TypeInt, TypeObject))
<a name="1387"></a>        return res;
<a name="1388"></a>    
<a name="1389"></a>   
<a name="1390"></a>    
<a name="1391"></a>    /* 
<a name="1392"></a>     *   We can't find a valid interpretation of val as a number, so return nil.
<a name="1393"></a>     */
<a name="1394"></a>    return nil;
<a name="1395"></a>}
<a name="1396"></a>
<a name="1397"></a>/* 
<a name="1398"></a> *   Try converting val to a number (integer or BigNumber); return the number if
<a name="1399"></a> *   there is one, otherwise return nil.
<a name="1400"></a> */
<a name="1401"></a>tryNum(val)
<a name="1402"></a>{
<a name="1403"></a>     /* 
<a name="1404"></a>     *   If the value passed to the function is neither an integer nor a string
<a name="1405"></a>     *   nor a BigNumber, return nil, since there can be no valid numerical
<a name="1406"></a>     *   representation of it.
<a name="1407"></a>     */    
<a name="1408"></a>    if(dataType(val) not in (TypeInt, TypeSString, TypeObject)
<a name="1409"></a>       || (dataType(val) == TypeObject &amp;&amp; !val.ofKind(BigNumber)))
<a name="1410"></a>        return nil;
<a name="1411"></a>    
<a name="1412"></a>    /* If val is already a BigNumber, return it unchanged. */
<a name="1413"></a>    if(dataType(val) == TypeObject &amp;&amp; val.ofKind(BigNumber))
<a name="1414"></a>        return val;
<a name="1415"></a>    
<a name="1416"></a>   
<a name="1417"></a>
<a name="1418"></a>    /*  
<a name="1419"></a>     *   If val is a string then test whether it matches a valid numerical
<a name="1420"></a>     *   pattern.
<a name="1421"></a>     */
<a name="1422"></a>    if(dataType(val) == TypeSString)
<a name="1423"></a>    {
<a name="1424"></a>        val = stripQuotesFrom(val.findReplace(' ',''));
<a name="1425"></a>        
<a name="1426"></a>        /* Try converting val to a number */
<a name="1427"></a>        local res = toNumber(val);
<a name="1428"></a>        
<a name="1429"></a>        if(val.match(R'(&lt;plus&gt;|-)?&lt;digit&gt;+$'))
<a name="1430"></a>            return res;
<a name="1431"></a>        
<a name="1432"></a>        if(val.match(R'(&lt;plus&gt;|-)?&lt;digit&gt;*&lt;dot&gt;&lt;digit&gt;+$'))
<a name="1433"></a>            return res;
<a name="1434"></a>        
<a name="1435"></a>        if(val.match(R'(&lt;plus&gt;|-)?&lt;digit&gt;+(&lt;dot&gt;&lt;digit&gt;+)?[eE]&lt;digit&gt;?+$'))
<a name="1436"></a>            return res;
<a name="1437"></a>    }
<a name="1438"></a>    
<a name="1439"></a>
<a name="1440"></a>    /* Otherwise use the tryInt() function to return the result */
<a name="1441"></a>    return tryInt(val);
<a name="1442"></a>}
<a name="1443"></a>
<a name="1444"></a>
<a name="1445"></a>
<a name="1446"></a>
<a name="1447"></a>
<a name="1448"></a>/*
<a name="1449"></a> *   nilToList - convert a 'nil' value to an empty list.  This can be
<a name="1450"></a> *   useful for mix-in classes that will be used in different inheritance
<a name="1451"></a> *   contexts, since the classes might or might not inherit a base class
<a name="1452"></a> *   definition for list-valued methods such as preconditions.  This
<a name="1453"></a> *   provides a usable default for list-valued methods that return nothing
<a name="1454"></a> *   from superclasses. 
<a name="1455"></a> */
<a name="1456"></a>nilToList(val)
<a name="1457"></a>{
<a name="1458"></a>    return (val != nil ? val : []);
<a name="1459"></a>}
<a name="1460"></a>
<a name="1461"></a>/*      
<a name="1462"></a> *   val to list - convert any value to a list. If it's already a list, simply
<a name="1463"></a> *   return it. If it's nil return an empty list. If it's a singleton value,
<a name="1464"></a> *   return a one-element list containing it.
<a name="1465"></a> */
<a name="1466"></a>valToList(val)
<a name="1467"></a>{
<a name="1468"></a>    switch (dataType(val))
<a name="1469"></a>    {
<a name="1470"></a>    case TypeNil:
<a name="1471"></a>        return [];
<a name="1472"></a>    case TypeList:
<a name="1473"></a>        return val;
<a name="1474"></a>    case TypeObject:
<a name="1475"></a>        if(val.ofKind(Vector))
<a name="1476"></a>            return val.toList;
<a name="1477"></a>        else
<a name="1478"></a>            return [val];
<a name="1479"></a>    default:
<a name="1480"></a>        return [val];
<a name="1481"></a>    }
<a name="1482"></a>}
<a name="1483"></a>
<a name="1484"></a>/*  
<a name="1485"></a> *   Set the mentioned property of obj to true. If obj is supplied as a list,
<a name="1486"></a> *   set every object's mentioned property in the list to true. This can be used
<a name="1487"></a> *   in room and object descriptions to mark an object as mentioned so it won't
<a name="1488"></a> *   be included in the listing.
<a name="1489"></a> */
<a name="1490"></a>makeMentioned(obj)
<a name="1491"></a>{
<a name="1492"></a>    foreach(local cur in valToList(obj))
<a name="1493"></a>        cur.mentioned = true;
<a name="1494"></a>}
<a name="1495"></a>
<a name="1496"></a>
<a name="1497"></a>/* 
<a name="1498"></a> *   partitionList - partition a list into a pair of two lists, the first
<a name="1499"></a> *   containing items that match the predicate 'fn', the second containing
<a name="1500"></a> *   items that don't match 'fn'.  'fn' is a function pointer (usually an
<a name="1501"></a> *   anonymous function) that takes a single argument - a list element -
<a name="1502"></a> *   and returns true or nil.
<a name="1503"></a> *   
<a name="1504"></a> *   The return value is a list with two elements.  The first element is a
<a name="1505"></a> *   list giving the elements of the original list for which 'fn' returns
<a name="1506"></a> *   true, the second element is a list giving the elements for which 'fn'
<a name="1507"></a> *   returns nil.
<a name="1508"></a> *   
<a name="1509"></a> *   (Contributed by Tommy Nordgren.)  
<a name="1510"></a> */
<a name="1511"></a>partitionList(lst, fn)
<a name="1512"></a>{
<a name="1513"></a>    local lst1 = lst.subset(fn);
<a name="1514"></a>    local lst2 = lst.subset({x : !fn(x)});
<a name="1515"></a>    
<a name="1516"></a>    return [lst1, lst2];
<a name="1517"></a>}
<a name="1518"></a>
<a name="1519"></a>/*
<a name="1520"></a> *   Determine if list a is a subset of list b.  a is a subset of b if
<a name="1521"></a> *   every element of a is in b.  
<a name="1522"></a> */
<a name="1523"></a>isListSubset(a, b)
<a name="1524"></a>{
<a name="1525"></a>    /* a can't be a subset if it has more elements than b */
<a name="1526"></a>    if (a.length() &gt; b.length())
<a name="1527"></a>        return nil;
<a name="1528"></a>    
<a name="1529"></a>    /* check each element of a to see if it's also in b */
<a name="1530"></a>    foreach (local cur in a)
<a name="1531"></a>    {
<a name="1532"></a>        /* if this element of a is not in b, a is not a subset of b */
<a name="1533"></a>        if (b.indexOf(cur) == nil)
<a name="1534"></a>            return nil;
<a name="1535"></a>    }
<a name="1536"></a>
<a name="1537"></a>    /* 
<a name="1538"></a>     *   we didn't find any elements of a that are not also in b, so a is a
<a name="1539"></a>     *   subset of b 
<a name="1540"></a>     */
<a name="1541"></a>    return true;
<a name="1542"></a>}
<a name="1543"></a>
<a name="1544"></a>
<a name="1545"></a>/* 
<a name="1546"></a> *   Find an existing Topic whose vocab is voc. If the cls parameter
<a name="1547"></a> *   is supplied it can be used to find a match in some other class, such as
<a name="1548"></a> *   Thing or Mentionable.
<a name="1549"></a> */
<a name="1550"></a>findMatchingTopic(voc, cls = Topic)
<a name="1551"></a>{
<a name="1552"></a>    for(local cur = firstObj(cls); cur != nil; cur = nextObj(cur, cls))
<a name="1553"></a>    {
<a name="1554"></a>        if(cur.vocab == voc)
<a name="1555"></a>            return cur;
<a name="1556"></a>    }
<a name="1557"></a>    
<a name="1558"></a>    return nil;
<a name="1559"></a>}
<a name="1560"></a>
<a name="1561"></a>/* 
<a name="1562"></a> *   Set the player character to another actor. If the optional second parameter
<a name="1563"></a> *   is supplied, it sets the person of the player character; otherwise it
<a name="1564"></a> *   defaults to the second person.
<a name="1565"></a> */
<a name="1566"></a>setPlayer(actor, person = 2)
<a name="1567"></a>{    
<a name="1568"></a>    /* Note the old player character */
<a name="1569"></a>    local other = gPlayerChar;
<a name="1570"></a>    
<a name="1571"></a>    /* Note the name of the actor the pc is about to become */
<a name="1572"></a>    local newName = actor.theName;
<a name="1573"></a>    
<a name="1574"></a>    /* Change the player character to actor */
<a name="1575"></a>    gPlayerChar = actor;
<a name="1576"></a>    
<a name="1577"></a>    /* Change the player character person to person. */
<a name="1578"></a>    gPlayerChar.person = person;
<a name="1579"></a>    
<a name="1580"></a>    /* Change the person of the previous player character to 3 */
<a name="1581"></a>    other.person = 3;
<a name="1582"></a>    
<a name="1583"></a>    /* 
<a name="1584"></a>     *   Change the names of both actors involved in the swap to nil, so that
<a name="1585"></a>     *   they can be reinitialized.
<a name="1586"></a>     */
<a name="1587"></a>    other.name = nil;
<a name="1588"></a>    gPlayerChar.name = nil;
<a name="1589"></a>    
<a name="1590"></a>    /*   
<a name="1591"></a>     *   Reinitialize the names of both actors, so that the player character can
<a name="1592"></a>     *   become 'I' or 'You' as appropriate, and the previous PC acquires
<a name="1593"></a>     *   his/her third-person name.
<a name="1594"></a>     */
<a name="1595"></a>    other.initVocab();
<a name="1596"></a>    gPlayerChar.initVocab();
<a name="1597"></a>    
<a name="1598"></a>    /*   Note the name (e.g. 'Bob' or 'Mary') of the new player character */
<a name="1599"></a>    libGlobal.playerCharName = newName;
<a name="1600"></a>    
<a name="1601"></a>    /*   Make the current actor the new player character */
<a name="1602"></a>    gActor = gPlayerChar;
<a name="1603"></a>    gCommand.actor = gPlayerChar;
<a name="1604"></a>    
<a name="1605"></a>    /* Return the (third-person) name of the new player character */
<a name="1606"></a>    return newName;
<a name="1607"></a>}
<a name="1608"></a>
<a name="1609"></a>/* ------------------------------------------------------------------------ */
<a name="1610"></a>/*
<a name="1611"></a> *   Add some methods to the base Object that make it *somewhat*
<a name="1612"></a> *   interchangeable with lists and vectors.  Certain operations that are
<a name="1613"></a> *   normally specific to the collection types have obvious degenerations
<a name="1614"></a> *   for the singleton case.  In particular, a singleton can be thought of
<a name="1615"></a> *   as a collection consisting of one value, so operations that iterate
<a name="1616"></a> *   over a collection degenerate to one iteration on a singleton.  
<a name="1617"></a> */
<a name="1618"></a>modify Object
<a name="1619"></a>    /* mapAll for an object simply applies a function to the object */
<a name="1620"></a>    mapAll(func)
<a name="1621"></a>    {
<a name="1622"></a>        return func(self);
<a name="1623"></a>    }
<a name="1624"></a>
<a name="1625"></a>    /* forEach on an object simply calls the function on the object */
<a name="1626"></a>    forEach(func)
<a name="1627"></a>    {
<a name="1628"></a>        return func(self);
<a name="1629"></a>    }
<a name="1630"></a>
<a name="1631"></a>    /* create an iterator */
<a name="1632"></a>    createIterator()
<a name="1633"></a>    {
<a name="1634"></a>        return new SingletonIterator(self);
<a name="1635"></a>    }
<a name="1636"></a>
<a name="1637"></a>    /* 
<a name="1638"></a>     *   create a live iterator (this allows 'foreach' to be used with an
<a name="1639"></a>     *   arbitrary object, iterating once over the loop with the object
<a name="1640"></a>     *   value) 
<a name="1641"></a>     */
<a name="1642"></a>    createLiveIterator()
<a name="1643"></a>    {
<a name="1644"></a>        return new SingletonIterator(self);
<a name="1645"></a>    }
<a name="1646"></a>
<a name="1647"></a>    /*
<a name="1648"></a>     *   Call an inherited method directly.  This has the same effect that
<a name="1649"></a>     *   calling 'inherited cl.prop' would from within a method, but allows
<a name="1650"></a>     *   you to do this from an arbitrary point *outside* of the object's
<a name="1651"></a>     *   own code.  I.e., you can say 'obj.callInherited(cl, &amp;prop)' and
<a name="1652"></a>     *   get the effect that 'inherited c.prop' would have had from within
<a name="1653"></a>     *   an 'obj' method.  
<a name="1654"></a>     */
<a name="1655"></a>    callInherited(cl, prop, [args])
<a name="1656"></a>    {
<a name="1657"></a>        delegated cl.(prop)(args...);
<a name="1658"></a>    }
<a name="1659"></a>;
<a name="1660"></a>
<a name="1661"></a>/*
<a name="1662"></a> *   A SingletonIterator is an implementation of the Iterator interface for
<a name="1663"></a> *   singleton values.  This allows 'foreach' to be used with arbitrary
<a name="1664"></a> *   objects, or even primitive values.  The effect of iterating over a
<a name="1665"></a> *   singleton value with 'foreach' using this iterator is simply to invoke
<a name="1666"></a> *   the loop once with the loop variable set to the singleton value.  
<a name="1667"></a> */
<a name="1668"></a>class SingletonIterator: object
<a name="1669"></a>    /* construction: save the singleton value that we're "iterating" over */
<a name="1670"></a>    construct(val) { val_ = val; }
<a name="1671"></a>
<a name="1672"></a>    /* get the next value */
<a name="1673"></a>    getNext()
<a name="1674"></a>    {
<a name="1675"></a>        /* note that we've consumed the value */
<a name="1676"></a>        more_ = nil;
<a name="1677"></a>
<a name="1678"></a>        /* return the value */
<a name="1679"></a>        return val_;
<a name="1680"></a>    }
<a name="1681"></a>
<a name="1682"></a>    /* is another item available? */
<a name="1683"></a>    isNextAvailable() { return more_; }
<a name="1684"></a>
<a name="1685"></a>    /* reset: restore the flag that says the value is available */
<a name="1686"></a>    resetIterator() { more_ = true; }
<a name="1687"></a>
<a name="1688"></a>    /* get the current key; we have no keys, so use a fake key of nil */
<a name="1689"></a>    getKey() { return nil; }
<a name="1690"></a>
<a name="1691"></a>    /* get the current value */
<a name="1692"></a>    getCurVal() { return val_; }
<a name="1693"></a>    
<a name="1694"></a>    /* the singleton value we're "iterating" over */
<a name="1695"></a>    val_ = nil
<a name="1696"></a>    
<a name="1697"></a>    /* do we have any more values to fetch? */
<a name="1698"></a>    more_ = true
<a name="1699"></a>;
<a name="1700"></a>
<a name="1701"></a>/*
<a name="1702"></a> *   Add some convenience methods to String. 
<a name="1703"></a> */
<a name="1704"></a>modify String
<a name="1705"></a>    /*
<a name="1706"></a>     *   Trim spaces.  Removes leading and trailing spaces from the string.
<a name="1707"></a>     */
<a name="1708"></a>    trim()
<a name="1709"></a>    {
<a name="1710"></a>        return findReplace(trimPat, '');
<a name="1711"></a>    }
<a name="1712"></a>
<a name="1713"></a>    /* regular expression for trimming leading and trailing spaces */
<a name="1714"></a>    trimPat = R'^&lt;space&gt;+|&lt;space&gt;+$'
<a name="1715"></a>
<a name="1716"></a>    /* get the first character */
<a name="1717"></a>    firstChar() { return substr(1, 1); }
<a name="1718"></a>
<a name="1719"></a>    /* get the last character */
<a name="1720"></a>    lastChar() { return substr(length()); }
<a name="1721"></a>
<a name="1722"></a>    /* remove the first character */
<a name="1723"></a>    delFirst() { return substr(2); }
<a name="1724"></a>
<a name="1725"></a>    /* remove the last character */
<a name="1726"></a>    delLast() { return substr(1, length() - 1); }
<a name="1727"></a>
<a name="1728"></a>    /* leftmost n characters; if n is negative, leftmost (length-n) */
<a name="1729"></a>    left(n) { return n &gt;= 0 ? substr(1, n) : substr(1, length() + n); }
<a name="1730"></a>
<a name="1731"></a>    /* rightmost n characters; if n is negative, rightmost (length-n) */
<a name="1732"></a>    right(n) { return n &gt;= 0 ? substr(-n) : substr(n + length()); }    
<a name="1733"></a>    ;
<a name="1734"></a>
<a name="1735"></a>/* A string is empty if it's nil or if when trimmed it's '' */
<a name="1736"></a>isEmptyStr(str) {  return (str == nil || str.trim() == ''); }
<a name="1737"></a>
<a name="1738"></a>
<a name="1739"></a>/*
<a name="1740"></a> *   Add a couple of handy utility functions to Vector 
<a name="1741"></a> */
<a name="1742"></a>modify Vector
<a name="1743"></a>    /* is the vector empty? */
<a name="1744"></a>    isEmpty() { return length() == 0; }
<a name="1745"></a>
<a name="1746"></a>    /* clear the vector */
<a name="1747"></a>    clear() 
<a name="1748"></a>    {
<a name="1749"></a>        if (length() &gt; 0)
<a name="1750"></a>            removeRange(1, length()); 
<a name="1751"></a>    }
<a name="1752"></a>
<a name="1753"></a>    /* get the "top" item, treating the vector as a stack */
<a name="1754"></a>    getTop() { return self[length()]; }
<a name="1755"></a>
<a name="1756"></a>    /* push a value (append it to the end of the vector) */
<a name="1757"></a>    push(val) { append(val); }
<a name="1758"></a>
<a name="1759"></a>    /* pop a value (remove and return the value at the end of the vector) */
<a name="1760"></a>    pop()
<a name="1761"></a>    {
<a name="1762"></a>        local l = length();
<a name="1763"></a>        if (l &gt; 0)
<a name="1764"></a>        {
<a name="1765"></a>            /* get the last value */
<a name="1766"></a>            local ret = self[l];
<a name="1767"></a>
<a name="1768"></a>            /* remove the element */
<a name="1769"></a>            removeElementAt(l);
<a name="1770"></a>
<a name="1771"></a>            /* return it */
<a name="1772"></a>            return ret;
<a name="1773"></a>        }
<a name="1774"></a>        else
<a name="1775"></a>        {
<a name="1776"></a>            /* intentionally cause an out-of-bounds error */
<a name="1777"></a>            return self[1];
<a name="1778"></a>        }
<a name="1779"></a>    }
<a name="1780"></a>
<a name="1781"></a>    /* unshift a value (insert it at the start of the Vector) */
<a name="1782"></a>    unshift(val) { prepend(val); }
<a name="1783"></a>
<a name="1784"></a>    /* shift a value (remove and return the first value) */
<a name="1785"></a>    shift()
<a name="1786"></a>    {
<a name="1787"></a>        local l = length();
<a name="1788"></a>        if (l &gt; 0)
<a name="1789"></a>        {
<a name="1790"></a>            /* get the first value */
<a name="1791"></a>            local ret = self[1];
<a name="1792"></a>
<a name="1793"></a>            /* remove the element */
<a name="1794"></a>            removeElementAt(1);
<a name="1795"></a>
<a name="1796"></a>            /* return it */
<a name="1797"></a>            return ret;
<a name="1798"></a>        }
<a name="1799"></a>        else
<a name="1800"></a>        {
<a name="1801"></a>            /* intentionally cause an out-of-bounds error */
<a name="1802"></a>            return self[1];
<a name="1803"></a>        }
<a name="1804"></a>    }
<a name="1805"></a>
<a name="1806"></a>    /*
<a name="1807"></a>     *   Perform a "group sort" on the vector.  This sorts the items into
<a name="1808"></a>     *   groups, then sorts by an ordering value within each group.
<a name="1809"></a>     *   
<a name="1810"></a>     *   The groups are determined by group keys, which are arbitrary
<a name="1811"></a>     *   values.  Each group is simply the set of objects with a like value
<a name="1812"></a>     *   for the key.  Within the group, we sort by an integer ordering
<a name="1813"></a>     *   key.
<a name="1814"></a>     *   
<a name="1815"></a>     *   'func' is a function that takes two parameters: func(entry, idx),
<a name="1816"></a>     *   where 'entry' is a list element and 'idx' is an index in the list.
<a name="1817"></a>     *   This returns a list, [group, order], giving the group key and
<a name="1818"></a>     *   ordering key for the entry.  
<a name="1819"></a>     */
<a name="1820"></a>    groupSort(func)
<a name="1821"></a>    {
<a name="1822"></a>        /* note our length */
<a name="1823"></a>        local len = length();
<a name="1824"></a>
<a name="1825"></a>        /* 
<a name="1826"></a>         *   set up a lookup table for the group keys - we want to assign
<a name="1827"></a>         *   each one an arbitrary integer value so that we can sort by it 
<a name="1828"></a>         */
<a name="1829"></a>        local groups = new LookupTable(16, 32);
<a name="1830"></a>        local gnxt = 1;
<a name="1831"></a>        
<a name="1832"></a>        /* decorate each entry with its group index and ordering key */
<a name="1833"></a>        for (local i = 1 ; i &lt;= len ; ++i)
<a name="1834"></a>        {
<a name="1835"></a>            /* get this element */
<a name="1836"></a>            local ele = self[i];
<a name="1837"></a>
<a name="1838"></a>            /* get the group info via the callback */
<a name="1839"></a>            local info = func(ele, i);
<a name="1840"></a>
<a name="1841"></a>            /* look up or assign this group key's number */
<a name="1842"></a>            local gnum = groups[info[1]];
<a name="1843"></a>            if (gnum == nil)
<a name="1844"></a>                groups[info[1]] = gnum = gnxt++;
<a name="1845"></a>
<a name="1846"></a>            /* store the group number and sorting order in the list */
<a name="1847"></a>            self[i] = [gnum, info[2], ele];
<a name="1848"></a>        }
<a name="1849"></a>
<a name="1850"></a>        /* do the sort */
<a name="1851"></a>        sort(SortAsc, new function(a, b) {
<a name="1852"></a>            /* 
<a name="1853"></a>             *   if the groups are the same, sort by the order within the
<a name="1854"></a>             *   group; otherwise sort by the group number 
<a name="1855"></a>             */
<a name="1856"></a>            if (a[1] == b[1])
<a name="1857"></a>                return a[2] - b[2];
<a name="1858"></a>            else
<a name="1859"></a>                return a[1] - b[1];
<a name="1860"></a>        });
<a name="1861"></a>
<a name="1862"></a>        /* remove the extra information from the list */
<a name="1863"></a>        for (local i = 1 ; i &lt;= len ; ++i)
<a name="1864"></a>            self[i] = self[i][3];
<a name="1865"></a>    }
<a name="1866"></a>
<a name="1867"></a>    /* find a list element - synonym for indexOf */
<a name="1868"></a>    find(ele) { return indexOf(ele); }
<a name="1869"></a>
<a name="1870"></a>    /* shuffle the elements of the vector into a random order */
<a name="1871"></a>    shuffle()
<a name="1872"></a>    {
<a name="1873"></a>        /*
<a name="1874"></a>         *   The basic algorithm for shuffling is that we put all of the
<a name="1875"></a>         *   elements into a bag, and one by one we withdraw an element at
<a name="1876"></a>         *   random and add it to the result list.  To withdraw a random
<a name="1877"></a>         *   element, we simply pick a random number from 1 to the number
<a name="1878"></a>         *   of items left in the bag.
<a name="1879"></a>         *   
<a name="1880"></a>         *   With a vector, we can do this without allocating any more
<a name="1881"></a>         *   memory.  We partition the vector into two parts: the "result"
<a name="1882"></a>         *   part and the "bag" part.  Initially, the whole vector is the
<a name="1883"></a>         *   bag, and the result part is empty.  We next pick a random
<a name="1884"></a>         *   element from the bag, and swap it with element #N.  This
<a name="1885"></a>         *   effectively deletes the chosen element from the bag and fills
<a name="1886"></a>         *   in the hole with the bag element that was formerly at slot #N.
<a name="1887"></a>         *   (If we chose the element at slot #N, that's fine - it just
<a name="1888"></a>         *   stays put.)  Slot #N is now part of the result set, and the
<a name="1889"></a>         *   bag is now slots #1 to #N-1.  We next pick a random element
<a name="1890"></a>         *   from the bag - 1..N-1 - and swap it with slot #N-1.  Now slot
<a name="1891"></a>         *   #N-1 is in the result set, and the bag is from #1 to #N-2.
<a name="1892"></a>         *   Repeat until we've chosen slot 2.  (We don't have to
<a name="1893"></a>         *   explicitly pick anything for slot 1, since at that point we're
<a name="1894"></a>         *   down to a single element in the bag, and it's already at the
<a name="1895"></a>         *   proper position to just redefine it as a result.)  
<a name="1896"></a>         */
<a name="1897"></a>        for (local len = length(), local n = len ; n &gt; 1 ; --n)
<a name="1898"></a>        {
<a name="1899"></a>            /* the bag is slots 1..n - pick a random element in that range */
<a name="1900"></a>            local r = rand(n) + 1;
<a name="1901"></a>
<a name="1902"></a>            /* swap the random element with element #n */
<a name="1903"></a>            local val = self[r];
<a name="1904"></a>            self[r] = self[n];
<a name="1905"></a>            self[n] = val;
<a name="1906"></a>        }
<a name="1907"></a>
<a name="1908"></a>        /* in case the caller wants the shuffled object, return self */
<a name="1909"></a>        return self;
<a name="1910"></a>    }
<a name="1911"></a>;
<a name="1912"></a>
<a name="1913"></a>
<a name="1914"></a>/* ------------------------------------------------------------------------ */
<a name="1915"></a>/*
<a name="1916"></a> *   Add some utility methods to List. 
<a name="1917"></a> */
<a name="1918"></a>modify List
<a name="1919"></a>    /*
<a name="1920"></a>     *   Check the list against a prototype (a list of data types).  This
<a name="1921"></a>     *   is useful for checking a varargs list to see if it matches a given
<a name="1922"></a>     *   prototype.  Each prototype element can be a TypeXxx type code, to
<a name="1923"></a>     *   match a value of the given native type; an object class, to match
<a name="1924"></a>     *   an instance of that class; 'any', to match a value of any type; or
<a name="1925"></a>     *   the special value '...', to match zero or more additional
<a name="1926"></a>     *   arguments.  If '...' is present, it must be the last prototype
<a name="1927"></a>     *   element.  
<a name="1928"></a>     */
<a name="1929"></a>    matchProto(proto)
<a name="1930"></a>    {
<a name="1931"></a>        /* compare each value against the prototype */
<a name="1932"></a>        local plen = proto.length(), vlen = length();
<a name="1933"></a>        for (local i = 1 ; i &lt;= plen ; ++i)
<a name="1934"></a>        {
<a name="1935"></a>            /* get this prototype element (i.e., a type code) */
<a name="1936"></a>            local t = proto[i];
<a name="1937"></a>
<a name="1938"></a>            /* if this is a varargs indicator, we have a match */
<a name="1939"></a>            if (t == '...')
<a name="1940"></a>                return true;
<a name="1941"></a>
<a name="1942"></a>            /* if we're past the end of the values, it's no match */
<a name="1943"></a>            if (i &gt; vlen)
<a name="1944"></a>                return nil;
<a name="1945"></a>
<a name="1946"></a>            /* get the value */
<a name="1947"></a>            local v = self[i];
<a name="1948"></a>
<a name="1949"></a>            /* check the type */
<a name="1950"></a>            if (t == 'any')
<a name="1951"></a>            {
<a name="1952"></a>                /* 'any' matches any value, so this one is a match */
<a name="1953"></a>            }
<a name="1954"></a>            else if (dataType(t) == TypeInt)
<a name="1955"></a>            {
<a name="1956"></a>                /* check that we match the given native type */
<a name="1957"></a>                if (dataTypeXlat(v) != t)
<a name="1958"></a>                    return nil;
<a name="1959"></a>            }
<a name="1960"></a>            else
<a name="1961"></a>            {
<a name="1962"></a>                /* otherwise, we have to match the object class */
<a name="1963"></a>                if (dataType(v) not in (TypeObject, TypeList, TypeSString)
<a name="1964"></a>                    || !v.ofKind(t))
<a name="1965"></a>                    return nil;
<a name="1966"></a>            }
<a name="1967"></a>        }
<a name="1968"></a>
<a name="1969"></a>        /* 
<a name="1970"></a>         *   We reached the end of the prototype without finding a
<a name="1971"></a>         *   mismatch.  The only remaining check is that we don't have any
<a name="1972"></a>         *   extra arguments in the value list.  As long as the lengths
<a name="1973"></a>         *   match, we have a match. 
<a name="1974"></a>         */
<a name="1975"></a>        return plen == vlen;
<a name="1976"></a>    }
<a name="1977"></a>
<a name="1978"></a>    /* toList() on a list simply returns the same list */
<a name="1979"></a>    toList() { return self; }
<a name="1980"></a>
<a name="1981"></a>    /* find a list element - synonym for indexOf */
<a name="1982"></a>    find(ele) { return indexOf(ele); }
<a name="1983"></a>
<a name="1984"></a>    /* 
<a name="1985"></a>     *   shuffle the list: return a new list with the elements of this list
<a name="1986"></a>     *   rearranged into a random order 
<a name="1987"></a>     */
<a name="1988"></a>    shuffle()
<a name="1989"></a>    {
<a name="1990"></a>        /* 
<a name="1991"></a>         *   Since a list is immutable, we can't shuffle the elements in
<a name="1992"></a>         *   place, which means we have to construct a new list.  One way
<a name="1993"></a>         *   would be to use the Vector.shuffle algorithm, appending each
<a name="1994"></a>         *   element chosen from the bag to a new result list under
<a name="1995"></a>         *   construction.  That would construct length()-1 intermediate
<a name="1996"></a>         *   lists, though, so it's pretty inefficient memory-wise.  The
<a name="1997"></a>         *   easier and more efficient way is to create a Vector with the
<a name="1998"></a>         *   same elements as the list, shuffle the Vector, and then
<a name="1999"></a>         *   convert the result back to a list.  This creates only the one
<a name="2000"></a>         *   intermediate value (the Vector), and it's very simple to code,
<a name="2001"></a>         *   so we'll take that approach.  
<a name="2002"></a>         */
<a name="2003"></a>        return new Vector(length(), self).shuffle().toList();
<a name="2004"></a>    }
<a name="2005"></a>    
<a name="2006"></a>    /* Determine whether this list has any elements in common with lst */    
<a name="2007"></a>    overlapsWith(lst)
<a name="2008"></a>    {
<a name="2009"></a>        return intersect(valToList(lst)).length &gt; 0;
<a name="2010"></a>    }
<a name="2011"></a>        
<a name="2012"></a>    /*  Returns the ith member of the list if there is one, or nil otherwise */
<a name="2013"></a>    element(i)
<a name="2014"></a>    {
<a name="2015"></a>        return length &gt;= i ? self[i] : nil;
<a name="2016"></a>    }
<a name="2017"></a>    
<a name="2018"></a>    /*  
<a name="2019"></a>     *   Compare two lists of strings using the cmp StringComparator; return
<a name="2020"></a>     *   true if all the corresponding strings in the two lists are the same
<a name="2021"></a>     *   (according to cmp) and nil otherwise.
<a name="2022"></a>     */
<a name="2023"></a>    strComp(lst, cmp)
<a name="2024"></a>    {
<a name="2025"></a>        if(lst.length != length)
<a name="2026"></a>            return nil;
<a name="2027"></a>        
<a name="2028"></a>        for(local i in 1 .. lst.length)
<a name="2029"></a>        {
<a name="2030"></a>            if(cmp.matchValues(self[i], lst[i]) == 0)
<a name="2031"></a>                return nil;
<a name="2032"></a>        }
<a name="2033"></a>        return true;
<a name="2034"></a>    }
<a name="2035"></a>;
<a name="2036"></a>
<a name="2037"></a>/* Add a method to Date as a workaround for a library bug */
<a name="2038"></a>modify Date
<a name="2039"></a>    /* 
<a name="2040"></a>     *   Get the Hours, Minutes, Seconds and Milliseconds of the current time as
<a name="2041"></a>     *   a four-element list; Date.getClockTime() is meant to do this, but
<a name="2042"></a>     *   doesn't work properly.
<a name="2043"></a>     */
<a name="2044"></a>    getHMS()
<a name="2045"></a>    {
<a name="2046"></a>        local hh = toInteger(formatDate('%H'));
<a name="2047"></a>        local mm = toInteger(formatDate('%M'));
<a name="2048"></a>        local ss = toInteger(formatDate('%S'));
<a name="2049"></a>        local ms = toInteger(formatDate('%N'));
<a name="2050"></a>        
<a name="2051"></a>        return [hh, mm, ss, ms];
<a name="2052"></a>    }
<a name="2053"></a>    
<a name="2054"></a>;
<a name="2055"></a>
<a name="2056"></a>/* ------------------------------------------------------------------------ */
<a name="2057"></a>/*
<a name="2058"></a> *   Library error.  This is a base class for internal errors within the
<a name="2059"></a> *   library.  
<a name="2060"></a> */
<a name="2061"></a>class LibraryError: Exception
<a name="2062"></a>    construct()
<a name="2063"></a>    {
<a name="2064"></a>        /* do the inherited work */
<a name="2065"></a>        inherited();
<a name="2066"></a>
<a name="2067"></a>        /* 
<a name="2068"></a>         *   As a debugging aid, break into the debugger, if it's running.
<a name="2069"></a>         *   This makes it easier during development to track down where
<a name="2070"></a>         *   errors are occurring.  This has no effect during normal
<a name="2071"></a>         *   execution in the interpreter, since the interpreter ignores
<a name="2072"></a>         *   this call when the debugger isn't present. 
<a name="2073"></a>         */
<a name="2074"></a>        t3DebugTrace(T3DebugBreak);
<a name="2075"></a>    }
<a name="2076"></a>    display = "Library Error"
<a name="2077"></a>;
<a name="2078"></a>
<a name="2079"></a>/*
<a name="2080"></a> *   A generic "argument mistmatch" error.  The library uses this for
<a name="2081"></a> *   functions that use matchProto() to handle multiple argument list
<a name="2082"></a> *   variations: when none of the allowed argument lists are found, the
<a name="2083"></a> *   function throws this error. 
<a name="2084"></a> */
<a name="2085"></a>class ArgumentMismatchError: LibraryError
<a name="2086"></a>    display = "Wrong arguments in function or method call"
<a name="2087"></a>;
<a name="2088"></a>
<a name="2089"></a>
<a name="2090"></a>
<a name="2091"></a>/* ------------------------------------------------------------------------ */
<a name="2092"></a>/*
<a name="2093"></a> *   LCS - class that computes the Longest Common Subsequence for two lists
<a name="2094"></a> *   or vectors.
<a name="2095"></a> *   
<a name="2096"></a> *   The LCS is most frequently used as a differencing tool, to compute a
<a name="2097"></a> *   description of how two data sets differ.  This is at the core of tools
<a name="2098"></a> *   like "diff", which shows the differences between two versions of a
<a name="2099"></a> *   file.  The LCS is the part of the two sets that's the same, so
<a name="2100"></a> *   everything in one of the sets that's not in the LCS is unique to that
<a name="2101"></a> *   set.  The standard diff algorithm computes the LCS, then generates a
<a name="2102"></a> *   list of edits by specifying a "delete" operation on each item in the
<a name="2103"></a> *   "new" set that's not in the LCS, and an "insert" operation on each
<a name="2104"></a> *   item in the "old" set that's not in the LCS.  Merge and sort the two
<a name="2105"></a> *   edit lists and you have basically the standard Unix "diff" output.
<a name="2106"></a> *   (Some diff utilities make the report more readable by combining
<a name="2107"></a> *   overlapping edit and insert operations into "update" operations.  But
<a name="2108"></a> *   it's really the same thing, of course.)
<a name="2109"></a> *   
<a name="2110"></a> *   The constructor does all the work: use 'new' to create an instance of
<a name="2111"></a> *   this class, providing the two lists to be compared as arguments.  The
<a name="2112"></a> *   resulting object contains the LCS information.
<a name="2113"></a> *   
<a name="2114"></a> *   Note that you can use this class to generate a character-by-character
<a name="2115"></a> *   LCS for two strings, simply by using toUnicode() to convert each
<a name="2116"></a> *   string to a list of character values.  
<a name="2117"></a> */
<a name="2118"></a>class LCS: object
<a name="2119"></a>    construct(a, b)
<a name="2120"></a>    {
<a name="2121"></a>        local i, j, ka, kb;
<a name="2122"></a>
<a name="2123"></a>        /* get the input list lengths */
<a name="2124"></a>        local alen = a.length(), blen = b.length();
<a name="2125"></a>
<a name="2126"></a>        /* set up the length array, alen x blen, initialized with 0s */
<a name="2127"></a>        local c = new Vector(alen+1).fillValue(nil, 1, alen+1);
<a name="2128"></a>        c.applyAll({ ele: new Vector(blen+1).fillValue(0, 1, blen+1) });
<a name="2129"></a>
<a name="2130"></a>        /* set up the arrow array, alen x blen */
<a name="2131"></a>        local arr = new Vector(alen+1).fillValue(nil, 1, alen+1);
<a name="2132"></a>        arr.applyAll({ ele: new Vector(blen+1).fillValue(nil, 1, blen+1) });
<a name="2133"></a>
<a name="2134"></a>        /* apply the standard LCS algorithm */
<a name="2135"></a>        for (i = 1 ; i &lt;= alen ; ++i)
<a name="2136"></a>        {
<a name="2137"></a>            for (j = 1 ; j &lt;= blen ; ++j)
<a name="2138"></a>            {
<a name="2139"></a>                if (a[i] == b[j])
<a name="2140"></a>                {
<a name="2141"></a>                    /* up-left */
<a name="2142"></a>                    c[i+1][j+1] = c[i][j] + 1;
<a name="2143"></a>                    arr[i+1][j+1] = 3;
<a name="2144"></a>                }
<a name="2145"></a>                else if (c[i][j+1] &gt;= c[i+1][j])
<a name="2146"></a>                {
<a name="2147"></a>                    /* up */
<a name="2148"></a>                    c[i+1][j+1] = c[i][j+1];
<a name="2149"></a>                    arr[i+1][j+1] = 2;
<a name="2150"></a>                }
<a name="2151"></a>                else
<a name="2152"></a>                {
<a name="2153"></a>                    /* left */
<a name="2154"></a>                    c[i+1][j+1] = c[i+1][j];
<a name="2155"></a>                    arr[i+1][j+1] = 1;
<a name="2156"></a>                }
<a name="2157"></a>            }
<a name="2158"></a>        }
<a name="2159"></a>
<a name="2160"></a>        /* build the LCS list */
<a name="2161"></a>        local la = new Vector(alen), lb = new Vector(blen);
<a name="2162"></a>        for (i = alen+1, j = blen+1, ka = alen, kb = blen ; i &gt; 0 &amp;&amp; j &gt; 0 ; )
<a name="2163"></a>        {
<a name="2164"></a>            if (arr[i][j] == 3)
<a name="2165"></a>            {
<a name="2166"></a>                la[ka--] = i-1;
<a name="2167"></a>                lb[kb--] = j-1;
<a name="2168"></a>                --i;
<a name="2169"></a>                --j;
<a name="2170"></a>            }
<a name="2171"></a>            else if (arr[i][j] == 2)
<a name="2172"></a>                --i;
<a name="2173"></a>            else
<a name="2174"></a>                --j;
<a name="2175"></a>        }
<a name="2176"></a>
<a name="2177"></a>        /* save the LCSs, truncating the used portions */
<a name="2178"></a>        lcsA = la.toList().sublist(ka+1);
<a name="2179"></a>        lcsB = lb.toList().sublist(kb+1);
<a name="2180"></a>    }
<a name="2181"></a>
<a name="2182"></a>    /* the LCS, as lists of character indices into the respective strings */
<a name="2183"></a>    lcsA = nil
<a name="2184"></a>    lcsB = nil
<a name="2185"></a>;
<a name="2186"></a>
<a name="2187"></a>
<a name="2188"></a>/* ------------------------------------------------------------------------ */
<a name="2189"></a>/*
<a name="2190"></a> *   Change the case (upper/lower) of a given new string to match the case
<a name="2191"></a> *   pattern of the given original string.
<a name="2192"></a> *   
<a name="2193"></a> *   We recognize four patterns:
<a name="2194"></a> *   
<a name="2195"></a> *   - If the original string has at least one capital letter and no
<a name="2196"></a> *   minuscules, we convert the new string to all caps.  For example,
<a name="2197"></a> *   matchCase('ALPHA-1', 'omicron-7') yields 'OMICRON-7'.
<a name="2198"></a> *   
<a name="2199"></a> *   - If the original string has at least one lower-case letter and no
<a name="2200"></a> *   capitals, we convert the new string to all lower case.  E.g.,
<a name="2201"></a> *   matchCase('alpha-1', 'OMICRON-7') yields 'omicron-7'.
<a name="2202"></a> *   
<a name="2203"></a> *   - If the original string starts with a capital letter, and has at
<a name="2204"></a> *   least one lower-case letter and no other capitals, we capitalize the
<a name="2205"></a> *   first letter of the new string and lower-case everything else. E.g.,
<a name="2206"></a> *   matchCase('Alpha-1', 'OMICRON-7') yields 'Omicron-7'.
<a name="2207"></a> *   
<a name="2208"></a> *   - Otherwise, we match the case pattern of the input string letter for
<a name="2209"></a> *   letter: for each upper-case letter in the original, we capitalize the
<a name="2210"></a> *   letter at the corresponding character index in the new string, and
<a name="2211"></a> *   likewise with lower-case letters in the original.  We leave other
<a name="2212"></a> *   characters unchanged.  E.g., matchCase('AlPhA-1', 'omicron-7') yields
<a name="2213"></a> *   'OmIcRon-7'.  
<a name="2214"></a> */
<a name="2215"></a>matchCase(newTok, oldTok)
<a name="2216"></a>{
<a name="2217"></a>    /* 
<a name="2218"></a>     *   If the old token is all lower-case or all upper-case, it's easy.
<a name="2219"></a>     *   Only assume all upper-case if the original token has at least two
<a name="2220"></a>     *   capitals - for something like "I" we can't assume we want an
<a name="2221"></a>     *   all-caps word. 
<a name="2222"></a>     */
<a name="2223"></a>    if (rexMatch(R'&lt;^upper&gt;*&lt;lower&gt;+&lt;^upper&gt;*', oldTok) != nil)
<a name="2224"></a>        return newTok.toLower();
<a name="2225"></a>    if (rexMatch(R'&lt;^lower&gt;*&lt;upper&gt;+&lt;^lower&gt;*&lt;upper&gt;+&lt;^lower&gt;*', oldTok) != nil)
<a name="2226"></a>        return newTok.toUpper();
<a name="2227"></a>    
<a name="2228"></a>    /* another common and easy pattern is title case (initial cap) */
<a name="2229"></a>    if (rexMatch(R'&lt;upper&gt;&lt;^upper&gt;*&lt;lower&gt;+&lt;^upper&gt;*', oldTok) != nil)
<a name="2230"></a>        return newTok.firstChar().toUpper() + newTok.delFirst().toLower();
<a name="2231"></a>    
<a name="2232"></a>    /* do everything else letter by letter */
<a name="2233"></a>    local ret = '';
<a name="2234"></a>    for (local i = 1, local len = newTok.length() ; i &lt;= len ; ++i)
<a name="2235"></a>    {
<a name="2236"></a>        local cn = newTok.substr(i, 1);
<a name="2237"></a>        local co = oldTok.substr(i, 1);
<a name="2238"></a>        
<a name="2239"></a>        if (rexMatch(R'&lt;upper&gt;', co) != nil)
<a name="2240"></a>            ret += cn.toUpper();
<a name="2241"></a>        else if (rexMatch(R'&lt;lower&gt;', co) != nil)
<a name="2242"></a>            ret += cn.toUpper();
<a name="2243"></a>        else
<a name="2244"></a>            ret += cn;
<a name="2245"></a>    }
<a name="2246"></a>    
<a name="2247"></a>    /* return the result */
<a name="2248"></a>    return ret;
<a name="2249"></a>}
<a name="2250"></a>
<a name="2251"></a>
<a name="2252"></a>/* ------------------------------------------------------------------------ */
<a name="2253"></a>/*
<a name="2254"></a> *   Static object and class initializer.
<a name="2255"></a> *   
<a name="2256"></a> *   During startup, we'll automatically call the classInit() method for
<a name="2257"></a> *   each class object, and we'll call the default constructor for each
<a name="2258"></a> *   static object instance.  ("Static" objects are those defined directly
<a name="2259"></a> *   in the source code, as opposed to objects created dynamically with
<a name="2260"></a> *   'new'.)  This makes it easier to write initialization code by making
<a name="2261"></a> *   the process more uniform across static and dynamic objects.
<a name="2262"></a> *   
<a name="2263"></a> *   The first step is to call classInit() on each class.  We call this
<a name="2264"></a> *   method only each class that *directly* defines the method (i.e., we
<a name="2265"></a> *   don't call it on classes that only inherit the method from another
<a name="2266"></a> *   class).  We cycle through the objects in arbitrary order.  However,
<a name="2267"></a> *   you can control the relative order when there's a dependency by
<a name="2268"></a> *   setting the 'classInitFirst' property to a list of one or more classes
<a name="2269"></a> *   to initialize first.  When we encounter a class with this property,
<a name="2270"></a> *   we'll call the listed classes' classInit() methods before calling the
<a name="2271"></a> *   given class's classInit().
<a name="2272"></a> *   
<a name="2273"></a> *   The second step is to call constructStatic() or construct() on each
<a name="2274"></a> *   regular (non-class) object.  We only call this on *static* objects:
<a name="2275"></a> *   objects defined directly in the source code, as opposed to created
<a name="2276"></a> *   dynamically with 'new'.  As with classInit(), we visit the objects in
<a name="2277"></a> *   arbitrary order.  You can control dependencies using the
<a name="2278"></a> *   'constructFirst' method: set this to a list of objects to be
<a name="2279"></a> *   initialized before self.
<a name="2280"></a> *   
<a name="2281"></a> *   If an object defines or inherits a constructStatic() method, we'll
<a name="2282"></a> *   call it instead of construct().  Otherwise, if it defines or inherits
<a name="2283"></a> *   a construct() method with no arguments, we'll call it.  Otherwise
<a name="2284"></a> *   we'll do nothing.
<a name="2285"></a> *   
<a name="2286"></a> *   Note that it's possible for a base class to have a compatible
<a name="2287"></a> *   zero-argument constructor, but for a subclass to override this with a
<a name="2288"></a> *   constructor that takes arguments.  In this case, we'll search the
<a name="2289"></a> *   class tree for an inherited zero-argument constructor.  If we find
<a name="2290"></a> *   one, we'll call the inherited constructor.
<a name="2291"></a> *   
<a name="2292"></a> *   We can only call zero-argument construct() methods because we have no
<a name="2293"></a> *   basis for providing other arguments.  
<a name="2294"></a> */
<a name="2295"></a>libObjectInitializer: PreinitObject
<a name="2296"></a>    execBeforeMe = []
<a name="2297"></a>    execute()
<a name="2298"></a>    {
<a name="2299"></a>        /* build the reverse symbol table (indexed by object value) */
<a name="2300"></a>        local gtab = t3GetGlobalSymbols();
<a name="2301"></a>        local otab = new LookupTable(128, 256);
<a name="2302"></a>        gtab.forEachAssoc({ key, val: otab[val] = key });
<a name="2303"></a>
<a name="2304"></a>        /* save it in the PreinitObject class */
<a name="2305"></a>        PreinitObject.reverseGlobalSymbols = otab;
<a name="2306"></a>
<a name="2307"></a>        /* create a lookup table tracking which objects we've initialized */
<a name="2308"></a>        _initedTab = new LookupTable(256, 1024);
<a name="2309"></a>
<a name="2310"></a>        /* call classInit() on all classes */
<a name="2311"></a>        for (local o = firstObj(TadsObject, ObjClasses) ; o != nil ;
<a name="2312"></a>             o = nextObj(o, TadsObject, ObjClasses))
<a name="2313"></a>        {
<a name="2314"></a>            /* if this class directly defines a classInit() method, call it */
<a name="2315"></a>            if (o.propDefined(&amp;classInit, PropDefGetClass) == o)
<a name="2316"></a>                callConstructor(o, &amp;classInit, &amp;classInitFirst);
<a name="2317"></a>        }
<a name="2318"></a>
<a name="2319"></a>        /* call construct() or constructStatic() on all object instances */
<a name="2320"></a>        for (local o = firstObj(TadsObject, ObjInstances) ; o != nil ;
<a name="2321"></a>             o = nextObj(o, TadsObject, ObjInstances))
<a name="2322"></a>        {
<a name="2323"></a>            /* 
<a name="2324"></a>             *   Only call static objects - these will all have
<a name="2325"></a>             *   sourceTextOrder properties assigned by the compiler.
<a name="2326"></a>             *   
<a name="2327"></a>             *   Note that modified objects will inherit sourceTextOrder
<a name="2328"></a>             *   from a class - they're the only objects that do this,
<a name="2329"></a>             *   since the compiler only assigns sourceTextOrder initially
<a name="2330"></a>             *   to ordinary objects, but then class-ifies the base object
<a name="2331"></a>             *   when modifying it.  The only way that an object can
<a name="2332"></a>             *   inherit sourceTextOrder from a class is that the class is
<a name="2333"></a>             *   the original modified object, and the instance is the
<a name="2334"></a>             *   modifier.  
<a name="2335"></a>             */
<a name="2336"></a>            local cl = o.propDefined(&amp;sourceTextOrder, PropDefGetClass);
<a name="2337"></a>            if (cl == o || cl != nil &amp;&amp; cl.isClass())
<a name="2338"></a>            {
<a name="2339"></a>                /* 
<a name="2340"></a>                 *   It's a static object.  If it has a constructStatic()
<a name="2341"></a>                 *   method, call that.  Otherwise, if it has a construct()
<a name="2342"></a>                 *   method, call that.
<a name="2343"></a>                 */
<a name="2344"></a>                if (o.propDefined(&amp;constructStatic))
<a name="2345"></a>                {
<a name="2346"></a>                    /* it has constructStatic() */
<a name="2347"></a>                    callConstructor(o, &amp;constructStatic, &amp;constructFirst);
<a name="2348"></a>                }
<a name="2349"></a>                else if (o.propDefined(&amp;construct))
<a name="2350"></a>                {
<a name="2351"></a>                    /* call construct() */
<a name="2352"></a>                    callConstructor(o, &amp;construct, &amp;constructFirst);
<a name="2353"></a>                }
<a name="2354"></a>            }
<a name="2355"></a>        }
<a name="2356"></a>
<a name="2357"></a>        /* 
<a name="2358"></a>         *   done with the lookup table - explicitly remove it so that it
<a name="2359"></a>         *   doesn't take up space in the final compiled image 
<a name="2360"></a>         */
<a name="2361"></a>        _initedTab = nil;
<a name="2362"></a>
<a name="2363"></a>        /* likewise the reverse global symbol table */
<a name="2364"></a>        reverseGlobalSymbols = otab;
<a name="2365"></a>    }
<a name="2366"></a>
<a name="2367"></a>    /* call the given object's constructor */
<a name="2368"></a>    callConstructor(obj, conProp, preProp)
<a name="2369"></a>    {
<a name="2370"></a>        /* if obj has already been initialized, skip it */
<a name="2371"></a>        if (_initedTab[obj])
<a name="2372"></a>            return;
<a name="2373"></a>
<a name="2374"></a>        /* 
<a name="2375"></a>         *   mark this object as visited (do this first, before handling
<a name="2376"></a>         *   prerequisites, to break circular dependencies: if a
<a name="2377"></a>         *   prerequisite of ours lists us as a prerequisite, we'll see
<a name="2378"></a>         *   that we've already been initialized and stop the loop) 
<a name="2379"></a>         */
<a name="2380"></a>        _initedTab[obj] = true;
<a name="2381"></a>
<a name="2382"></a>        /* call constructors on any prerequisites */
<a name="2383"></a>        if (obj.propDefined(preProp))
<a name="2384"></a>        {
<a name="2385"></a>            foreach (local p in obj.(preProp))
<a name="2386"></a>                callConstructor(p, conProp, preProp);
<a name="2387"></a>        }
<a name="2388"></a>
<a name="2389"></a>        /* 
<a name="2390"></a>         *   if the given constructor is zero-argument constructor, call it
<a name="2391"></a>         *   directly; otherwise, look for an inherited constructor 
<a name="2392"></a>         */
<a name="2393"></a>        if (obj.getPropParams(conProp) == [0, 0, nil])
<a name="2394"></a>        {
<a name="2395"></a>            /* call the constructor */
<a name="2396"></a>            obj.(conProp)();
<a name="2397"></a>        }
<a name="2398"></a>        else
<a name="2399"></a>        {
<a name="2400"></a>            /* 
<a name="2401"></a>             *   Search the class tree for an inherited version of the
<a name="2402"></a>             *   constructor that takes zero arguments.  
<a name="2403"></a>             */
<a name="2404"></a>            for (local cl = obj.propDefined(conProp, PropDefGetClass) ;
<a name="2405"></a>                 cl != nil ;
<a name="2406"></a>                 cl = obj.propInherited(conProp, obj, cl, PropDefGetClass))
<a name="2407"></a>            {
<a name="2408"></a>                /* if this is a zero-argument version, call it */
<a name="2409"></a>                if (cl.getPropParams(conProp) == [0, 0, nil])
<a name="2410"></a>                {
<a name="2411"></a>                    /* invoke it */
<a name="2412"></a>                    obj.callInherited(cl, conProp);
<a name="2413"></a>
<a name="2414"></a>                    /* we're done looking */
<a name="2415"></a>                    break;
<a name="2416"></a>                }
<a name="2417"></a>            }
<a name="2418"></a>        }
<a name="2419"></a>    }
<a name="2420"></a>
<a name="2421"></a>    /* table of objects we've already initialized */
<a name="2422"></a>    _initedTab = nil
<a name="2423"></a>;
<a name="2424"></a>
<a name="2425"></a>/*
<a name="2426"></a> *   Our static object and class initializer should generally run before
<a name="2427"></a> *   any other initializers.  
<a name="2428"></a> */
<a name="2429"></a>modify PreinitObject
<a name="2430"></a>    /* execute the basic library initializer before any other initializers */
<a name="2431"></a>    execBeforeMe = [libObjectInitializer]
<a name="2432"></a>
<a name="2433"></a>    /* 
<a name="2434"></a>     *   class property: reverse lookup symbol table (a version of the
<a name="2435"></a>     *   global symbol table keyed by value, yielding the name of each
<a name="2436"></a>     *   global object, function, etc) 
<a name="2437"></a>     */
<a name="2438"></a>    reverseGlobalSymbols = nil
<a name="2439"></a>;
<a name="2440"></a>
<a name="2441"></a>/* 
<a name="2442"></a> *   Service function primarily intended for use with the symcomm extension to facilitate the use of
<a name="2443"></a> *   a string template, defined in advlite.h, allowing a string to vary by room. The arg parameter
<a name="2444"></a> *   should be supplied as a list of strings (symcomm expects a list of two, bur other uses could do
<a name="2445"></a> *   something different).
<a name="2446"></a> *
<a name="2447"></a> *   We need the function because a string template can't directly be defined in relation to a
<a name="2448"></a> *   method, so the byRoomFunc() function calls the byRoom() method on the object that invokes it.
<a name="2449"></a> */
<a name="2450"></a> byRoomFunc(arg)
<a name="2451"></a>{
<a name="2452"></a>    /* 
<a name="2453"></a>     *   We meed to get at the effective self object by using the stack frame. First obtain the
<a name="2454"></a>     *   stack frame one level back from us.
<a name="2455"></a>     */
<a name="2456"></a>    local frame = t3GetStackTrace(2, T3GetStackDesc).frameDesc_;
<a name="2457"></a>    
<a name="2458"></a>    /* Then get the self object in that stack frame. */
<a name="2459"></a>    local obj = frame.getSelf();
<a name="2460"></a>    
<a name="2461"></a>    /* Then call and return the byRoom() method on that object. */
<a name="2462"></a>    return obj.byRoom(arg);
<a name="2463"></a>}
<a name="2464"></a>
<a name="2465"></a>
<a name="2466"></a>/* Service function to determine whether obj is ofKind cls when obj might not be an object. */
<a name="2467"></a>objOfKind(obj, cls) { return dataTypeXlat(obj) == TypeObject &amp;&amp; obj.ofKind(cls); }
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 15/03/2023 from adv3Lite version 1.6.1</div>
</body>
</html>
