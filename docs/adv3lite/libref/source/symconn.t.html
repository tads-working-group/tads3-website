<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>symconn.t</title></head><body>
<table class=ban><tr><td><h1>symconn.t</h1><td align=right><a href="../file/symconn.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>#include "advlite.h"
<a name="3"></a>
<a name="4"></a>/*---------------------------------------------------------------------------*/
<a name="5"></a>/*
<a name="6"></a> *   SYMMETRICAL CONNECTOR (SYMCONN) EXTENSION
<a name="7"></a> */
<a name="8"></a>
<a name="9"></a>
<a name="10"></a>symconnID: ModuleID
<a name="11"></a>    name = 'Symconn'
<a name="12"></a>    byline = 'by Eric Eve'
<a name="13"></a>    htmlByline = 'by Eric Eve'
<a name="14"></a>    version = '2'    
<a name="15"></a>;
<a name="16"></a>
<a name="17"></a>/* Modification to Room for SymConn (symmetrical connector) extension */
<a name="18"></a>modify Room
<a name="19"></a>    /* 
<a name="20"></a>     *   Modified for SYMCOMM EXTENSION to set up symmetrical connectors at
<a name="21"></a>     *   preinit.
<a name="22"></a>     */
<a name="23"></a>    preinitThing()
<a name="24"></a>    {
<a name="25"></a>        /* Carry out the inherited handling. */
<a name="26"></a>        inherited();
<a name="27"></a>        
<a name="28"></a>        /* 
<a name="29"></a>         *   Go through each direction property listed in the Direction.opposites LookupTable.
<a name="30"></a>         */
<a name="31"></a>        foreach(local dir in Direction.allDirections)
<a name="32"></a>        {
<a name="33"></a>            
<a name="34"></a>            /* 
<a name="35"></a>             *   If this direction property on this room points to an object, then we may need to do
<a name="36"></a>             *   some setting up.
<a name="37"></a>             */
<a name="38"></a>            if(propType(dir.dirProp) == TypeObject)
<a name="39"></a>            {
<a name="40"></a>                /* Note the object this property is attached to */
<a name="41"></a>                local obj = self.(dir.dirProp);
<a name="42"></a>                
<a name="43"></a>                /* Note the property pointer for the reverse direction. */
<a name="44"></a>                local revProp = Direction.oppositeProp(dir.dirProp);             
<a name="45"></a>                
<a name="46"></a>                /* 
<a name="47"></a>                 *   If the object is a Room and its reverse direction property is nil, and the room
<a name="48"></a>                 *   has no connection back to us, then point that other room's reverse direction
<a name="49"></a>                 *   property to us, to make a symmetrical connection, provided we want reverse
<a name="50"></a>                 *   connections set up automatically.
<a name="51"></a>                 */
<a name="52"></a>                if(obj.ofKind(Room) &amp;&amp; obj.propType(revProp) == TypeNil
<a name="53"></a>                   &amp;&amp; autoBackConnections &amp;&amp; !obj.getDirectionTo(self))
<a name="54"></a>                    obj.(revProp) = self;
<a name="55"></a>                
<a name="56"></a>                /*  
<a name="57"></a>                 *   If the object is a SymConnector we need to carry out a different kind of
<a name="58"></a>                 *   initialization.
<a name="59"></a>                 */
<a name="60"></a>                if(obj.ofKind(SymConnector))
<a name="61"></a>                {
<a name="62"></a>                    /* First get the object to initialize itself. */
<a name="63"></a>                    obj.initConnector(self, dir);
<a name="64"></a>                    
<a name="65"></a>                    /* 
<a name="66"></a>                     *   Note the destination to which the SymConnector should lead from the current
<a name="67"></a>                     *   room. This may be nil if we're initializing this SymConnector from both its
<a name="68"></a>                     *   rooms and we haven't initialized it from the other side yet.
<a name="69"></a>                     */
<a name="70"></a>                    local dest = (obj.room2 == self ? obj.room1 : obj.room2);
<a name="71"></a>                    
<a name="72"></a>                    dest = dest ?? obj.destination;
<a name="73"></a>                    
<a name="74"></a>                    /*  
<a name="75"></a>                     *   If we have a destination and that destination's reverse direction property
<a name="76"></a>                     *   isn't already set, and the destination has no other direction set to the
<a name="77"></a>                     *   SymConnector, and we want to set up reverse directions automatically, then
<a name="78"></a>                     *   set the reverse direction to point to the SymConnector.
<a name="79"></a>                     */
<a name="80"></a>                    if(dest &amp;&amp; dest.propType(revProp) == TypeNil &amp;&amp; !dest.getDirection(obj)
<a name="81"></a>                       &amp;&amp; autoBackConnections)
<a name="82"></a>                    {
<a name="83"></a>                        dest.(revProp) = obj;
<a name="84"></a>                        
<a name="85"></a>                        if(obj.room1 == self &amp;&amp; obj.room2Dir == nil)
<a name="86"></a>                            obj.room2Dir = Direction.allDirections.valWhich({d: d.dirProp ==
<a name="87"></a>                                revProp});
<a name="88"></a>                    }
<a name="89"></a>                    
<a name="90"></a>                                         
<a name="91"></a>                }
<a name="92"></a>                /* 
<a name="93"></a>                 *   If we're attached to a TravelConnector that's neither a SymmConnector nor a
<a name="94"></a>                 *   Room, and autoBackConnection is true, and it's not a Door, try
<a name="95"></a>                 *   to set the reverse connection if it does not already exist.
<a name="96"></a>                 */
<a name="97"></a>                else if(obj.ofKind(TravelConnector) &amp;&amp; autoBackConnections &amp;&amp; !obj.ofKind(Room) 
<a name="98"></a>                        &amp;&amp; !obj.ofKind(Door))
<a name="99"></a>                {
<a name="100"></a>                    /* Note the destination to which this TravelConnector leads. */
<a name="101"></a>                    local dest = obj.getDestination(self);
<a name="102"></a>                    
<a name="103"></a>                    /* 
<a name="104"></a>                     *   If we have a destination and there's no way back from it to here and the
<a name="105"></a>                     *   reverse direction property of our destination is nil, then set that
<a name="106"></a>                     *   property to point back to us.
<a name="107"></a>                     */
<a name="108"></a>                    if(dest &amp;&amp; !dest.getDirectionTo(self) &amp;&amp; dest.propType(revProp) == TypeNil)
<a name="109"></a>                    {
<a name="110"></a>                        dest.(revProp) = self;                        
<a name="111"></a>                    }                   
<a name="112"></a>                }                
<a name="113"></a>                
<a name="114"></a>                /* 
<a name="115"></a>                 *   Ensure that any UnlistedProxyConnectors - usually defined by means of the
<a name="116"></a>                 *   asExit(macro) - are matched by an UnlistedProxyConnector in the opposite
<a name="117"></a>                 *   direction in destination room where the direction in question is either up or
<a name="118"></a>                 *   down, provided we want to create automatic back connections.
<a name="119"></a>                 */
<a name="120"></a>                if(obj.ofKind(UnlistedProxyConnector) &amp;&amp; dir.dirProp is in (&amp;up, &amp;down)
<a name="121"></a>                    &amp;&amp; autoBackConnections)
<a name="122"></a>                {
<a name="123"></a>                    local dest;
<a name="124"></a>                    
<a name="125"></a>                    /* 
<a name="126"></a>                     *   obtain the direction property for which the 
<a name="127"></a>                     *   UnlistedProxyConnector is a proxy.
<a name="128"></a>                     */
<a name="129"></a>                    local proxyProp = obj.direction.dirProp;
<a name="130"></a>                    
<a name="131"></a>                    /*  
<a name="132"></a>                     *   If this direction property points to an object, get its destination
<a name="133"></a>                     *   (assuming it's a TravelConnector or Room).
<a name="134"></a>                     */
<a name="135"></a>                    if(propType(proxyProp) == TypeObject)
<a name="136"></a>                        dest = self.(proxyProp).getDestination(self);
<a name="137"></a>                    
<a name="138"></a>                    /*  
<a name="139"></a>                     *   If we've found a destination, and its corresponding down or up property is
<a name="140"></a>                     *   undefined, then set up an UnlistedProxyConnector accordingly.
<a name="141"></a>                     */
<a name="142"></a>                    if(dest &amp;&amp; dest.propType(revProp) == TypeNil)
<a name="143"></a>                    {
<a name="144"></a>                        local backDir = dest.getDirectionTo(self);                        
<a name="145"></a>                        
<a name="146"></a>                        if(backDir)
<a name="147"></a>                            dest.(revProp) = new UnlistedProxyConnector(backDir);
<a name="148"></a>                    }
<a name="149"></a>                    
<a name="150"></a>                }           
<a name="151"></a>                              
<a name="152"></a>            }            
<a name="153"></a>        }   
<a name="154"></a>        
<a name="155"></a>    }
<a name="156"></a>    
<a name="157"></a>    /* 
<a name="158"></a>     *   Flag - do we want the library (specifically the preInit method of Thing) to automatically
<a name="159"></a>     *   create connections back (in the reverse direction) from any rooms our direction properties
<a name="160"></a>     *   (directlt, or indirectly via a TravelConnector) point to? By default we do (since that was
<a name="161"></a>     *   the part of the original purpose of the SymmConn extension) but game code can set this to
<a name="162"></a>     *   nil (either on the Room class or on individual rooms) to suppress it if it's not wanted -
<a name="163"></a>     *   which may be the case if the this extension is being used for SymmConnectors rather than
<a name="164"></a>     *   automated back connections.     */
<a name="165"></a>         
<a name="166"></a>    autoBackConnections = true
<a name="167"></a>    
<a name="168"></a>    /* 
<a name="169"></a>     *   update the vocab of any SymPassages in our contents list that have seperate room1Vocab and
<a name="170"></a>     *   room2Vocab
<a name="171"></a>     */
<a name="172"></a>    updateSymVocab()
<a name="173"></a>    {
<a name="174"></a>        /* loop through our contents */
<a name="175"></a>        foreach(local obj in contents)            
<a name="176"></a>        {
<a name="177"></a>            /* 
<a name="178"></a>             *   We're only interested in SymPassages (and subclasses thereof) that define both
<a name="179"></a>             *   their room1Vocab and room2Vocab properties as single-quoted strings.
<a name="180"></a>             */
<a name="181"></a>            if(obj.ofKind(SymPassage) &amp;&amp; obj.propType(&amp;room1Vocab) == TypeSString 
<a name="182"></a>               &amp;&amp; obj.propType(&amp;room2Vocab) == TypeSString)
<a name="183"></a>            {
<a name="184"></a>                /* 
<a name="185"></a>                 *   The new vocab we want to update this obj with is is room1Vocab if we're in its
<a name="186"></a>                 *   room1 and its room2Vocab otherwise.
<a name="187"></a>                 */
<a name="188"></a>                local newVocab = (obj.room1 == self ? obj.room1Vocab : obj.room2Vocab);
<a name="189"></a>                
<a name="190"></a>                /*   Update the vocab on obj. */
<a name="191"></a>                obj.replaceVocab(newVocab);
<a name="192"></a>            
<a name="193"></a>            }
<a name="194"></a>        }
<a name="195"></a>    }
<a name="196"></a>    
<a name="197"></a>    /*  
<a name="198"></a>     *   Modified in SYMCONN EXTENSION to update the vocab on any SymPassages in our destination.
<a name="199"></a>     */
<a name="200"></a>    notifyDeparture(traveler, dest)
<a name="201"></a>    {
<a name="202"></a>        /* first carry out the inherited handling */
<a name="203"></a>        inherited(traveler, dest);
<a name="204"></a>        
<a name="205"></a>        /* then update the vocab on our destination's SymPassages */        
<a name="206"></a>        if(gPlayerChar.isOrIsIn(traveler))
<a name="207"></a>            dest.updateSymVocab();
<a name="208"></a>    }
<a name="209"></a>;
<a name="210"></a>
<a name="211"></a>/* Modification to DirState for SymConn (symmetrical connector) extension */
<a name="212"></a>modify DirState    
<a name="213"></a>    /* 
<a name="214"></a>     *   We exclude SymStairway because including 'up' or 'down' in its vocab confuses the parser's
<a name="215"></a>     *   interpretation of CLIMB UP and CLIMB DOWN.
<a name="216"></a>     */
<a name="217"></a>    appliesTo(obj)
<a name="218"></a>    {
<a name="219"></a>        return inherited(obj) &amp;&amp; ! obj.ofKind(SymStairway);
<a name="220"></a>    }
<a name="221"></a>;
<a name="222"></a>
<a name="223"></a>/* 
<a name="224"></a> *   Ensure that the vocab of any SymPassages located in the player character's starting location
<a name="225"></a> *   have the vocab appropriate to the side from which they're viewed.
<a name="226"></a> */
<a name="227"></a>symVocabPreinit: PreinitObject
<a name="228"></a>    exec()
<a name="229"></a>    {
<a name="230"></a>        gPlayerChar.getOutermostRoom.updateSymVocab();
<a name="231"></a>    }
<a name="232"></a>    
<a name="233"></a>    /* 
<a name="234"></a>     *   The updateSymVocab() method depends on MultiLocs (which includes SymPassages) having
<a name="235"></a>     *   already been added to their locations' contents list, so we need to ensure that the
<a name="236"></a>     *   initialization of MultiLocs has been carried out first.
<a name="237"></a>     */
<a name="238"></a>    execBeforeMe = [multiLocInitiator]
<a name="239"></a>;
<a name="240"></a>
<a name="241"></a>
<a name="242"></a>/* 
<a name="243"></a> *   A Symmetrical Connector is a special type of TravelConnector between rooms that can be
<a name="244"></a> *   traversed in either direction and that, optionally, can largely set itself up so that if the
<a name="245"></a> *   dir property of room1 points to this SymConnector, the reverse dir property of room2 also
<a name="246"></a> *   points to this SymConnector. [SYMCOMM EXTENSION]
<a name="247"></a> *
<a name="248"></a> *   SymConnector is a type of TravelConnector (from which it descends by inheritance). A
<a name="249"></a> *   SymConnector can be traversed in both directions, and defining a SymConnector on a direction
<a name="250"></a> *   property of one room automatically attaches it to the reverse direction property of the room to
<a name="251"></a> *   which it leads. Otherwise, a SymConnector behaves much like any other TravelConnector, and can
<a name="252"></a> *   be used to define travel barriers or the side-effects of travel in much the same way.
<a name="253"></a> *
<a name="254"></a> *   Internally a SymConnector defines a room1 property and a room2 property, room1 and room2 being
<a name="255"></a> *   the two rooms reciprocally connected by the SymConnector. The room1 and room2 can be set by the
<a name="256"></a> *   extension at preinit if the connector's destination is specified, but it's probably clearer and
<a name="257"></a> *   safer to explictly set the room1 and room2 properties.
<a name="258"></a> */
<a name="259"></a>class SymConnector: TravelConnector
<a name="260"></a>    
<a name="261"></a>    /* 
<a name="262"></a>     *   The room from/to which this SymConnector leads. Note we can leave this
<a name="263"></a>     *   to be set up by our initConnector() method. [SYMCOMM EXTENSION] 
<a name="264"></a>     */
<a name="265"></a>    room1 = nil
<a name="266"></a>    
<a name="267"></a>     /* 
<a name="268"></a>      *   The room to/from which this SymConnector leads. [SYMCOMM EXTENSION] 
<a name="269"></a>      */
<a name="270"></a>    room2 = nil
<a name="271"></a>     
<a name="272"></a>    /* 
<a name="273"></a>     *   The direction an actor needs to travel in to travel via us from room1. This is set up in
<a name="274"></a>     *   Room initObj();
<a name="275"></a>     */
<a name="276"></a>    room1Dir = nil
<a name="277"></a>    
<a name="278"></a>    /* 
<a name="279"></a>     *   The direction an actor needs to travel in to travel via us from room2. This is set up in
<a name="280"></a>     *   Room initObj();
<a name="281"></a>     */
<a name="282"></a>    room2Dir = nil
<a name="283"></a>    
<a name="284"></a>    /*   
<a name="285"></a>     *   The name of our direction of travel from the point of view of the player character
<a name="286"></a>     *   depending on whether the pc is in room1 or room2.
<a name="287"></a>     */
<a name="288"></a>    dirName = inRoom1 ? room1Dir.name : room2Dir.name
<a name="289"></a>    
<a name="290"></a>    /*   
<a name="291"></a>     *   Our destination depends on our origin. [SYMCOMM EXTENSION] 
<a name="292"></a>     */
<a name="293"></a>    getDestination(origin)
<a name="294"></a>    {
<a name="295"></a>        /* If we start out from room1 then this connector leads to room2 */
<a name="296"></a>        if(origin == room1)
<a name="297"></a>            return room2;
<a name="298"></a>        
<a name="299"></a>        /* If we start out from room2 then this connector leads to room1 */
<a name="300"></a>        if(origin == room2)
<a name="301"></a>            return room1;
<a name="302"></a>        
<a name="303"></a>        /* Otherwise, it doesn't lead anywhere. */
<a name="304"></a>        return nil;
<a name="305"></a>    }
<a name="306"></a>    
<a name="307"></a>    /*  
<a name="308"></a>     *   Our notional destination (if this is defined it will be copied to room2
<a name="309"></a>     *   at preinit). [SYMCOMM EXTENSION] 
<a name="310"></a>     */
<a name="311"></a>    destination = nil
<a name="312"></a>        
<a name="313"></a>    
<a name="314"></a>    /*  
<a name="315"></a>     *   Execute travel through this connector. The difference for the SYMCOMM EXTENSION is that an
<a name="316"></a>     *   actor travelling through this connector ends up knowing where both sides lead to.
<a name="317"></a>     */
<a name="318"></a>    execTravel(actor, traveler, conn)
<a name="319"></a>    {
<a name="320"></a>        /* Note the actor's starting location. */
<a name="321"></a>        local loc = actor.getOutermostRoom();
<a name="322"></a>        
<a name="323"></a>        /* 
<a name="324"></a>         *   Carry out the inherited handling (which delegates most of the work
<a name="325"></a>         *   to our destination).
<a name="326"></a>         */
<a name="327"></a>        inherited(actor, traveler, conn);        
<a name="328"></a>        
<a name="329"></a>        
<a name="330"></a>        /*  
<a name="331"></a>         *   If the actor carrying out the travel is the player character, note
<a name="332"></a>         *   that the player character now knows where both sides of the
<a name="333"></a>         *   connector lead to.
<a name="334"></a>         */
<a name="335"></a>        if(actor == gPlayerChar &amp;&amp; actor.isIn(getDestination(loc)))        
<a name="336"></a>        {             
<a name="337"></a>            isDestinationKnown = true;
<a name="338"></a>        }
<a name="339"></a>    }
<a name="340"></a>    
<a name="341"></a>    /*   
<a name="342"></a>     *   By default the player character doesn't start off knowing where this
<a name="343"></a>     *   connector leads. Once the pc has been through the connector in either
<a name="344"></a>     *   direction this becomes true on both sides of the connector.
<a name="345"></a>	 *   [SYMCOMM EXTENSION] 
<a name="346"></a>     */
<a name="347"></a>    isDestinationKnown = nil
<a name="348"></a>    
<a name="349"></a>    /*   A SymConnector is usually open. [SYMCOMM EXTENSION] */
<a name="350"></a>    isOpen = true
<a name="351"></a>    
<a name="352"></a>    /*   
<a name="353"></a>     *   The rooms property provides an alternative and slightly shorthand way of defining our two
<a name="354"></a>     *   rooms. If defined, it must contain exactlty two rooms in the order [room1, room2].
<a name="355"></a>     */
<a name="356"></a>    rooms = []
<a name="357"></a>    
<a name="358"></a>    /*  
<a name="359"></a>     *   Initialize this SymConnector by setting up its room1 and room2 properties if they are not
<a name="360"></a>     *   already defined. This method is normally called from the preinitThing() method of the room
<a name="361"></a>     *   that first defines this connector. [SYMCOMM EXTENSION]
<a name="362"></a>     */
<a name="363"></a>    initConnector(loc, dir)
<a name="364"></a>    {
<a name="365"></a>        
<a name="366"></a>        /* 
<a name="367"></a>         *   Check if room1 and room2 have been defined on our rooms list property, and assign
<a name="368"></a>         *   them if so.
<a name="369"></a>         */
<a name="370"></a>        
<a name="371"></a>        rooms = valToList(rooms);
<a name="372"></a> 
<a name="373"></a>        
<a name="374"></a>        if(rooms.length &gt; 1)
<a name="375"></a>        {
<a name="376"></a>            room1 = rooms[1];
<a name="377"></a>            room2 = rooms[2];
<a name="378"></a>        }
<a name="379"></a>        
<a name="380"></a>        
<a name="381"></a>        /*  
<a name="382"></a>         *   If room1 hasn't been defined yet, set it to loc (the room whose
<a name="383"></a>         *   preinitThing() method has called this method), provided loc isn't room2.
<a name="384"></a>         */
<a name="385"></a>        if(room1 == nil &amp;&amp; room2 != loc)
<a name="386"></a>            room1 = loc;
<a name="387"></a>        
<a name="388"></a>        
<a name="389"></a>        /*  
<a name="390"></a>         *   If our destination property has been set to an object (which should
<a name="391"></a>         *   be a room), carry out some further setting up.
<a name="392"></a>         */
<a name="393"></a>        if(propType(&amp;destination) == TypeObject &amp;&amp; room2 == nil)
<a name="394"></a>        { 
<a name="395"></a>            /* Set our room2 property to our destination */
<a name="396"></a>            room2 = destination;    
<a name="397"></a>           
<a name="398"></a>        }
<a name="399"></a>        
<a name="400"></a>        
<a name="401"></a>        if(room1 == loc)
<a name="402"></a>            room1Dir = dir;
<a name="403"></a>        
<a name="404"></a>        if(room2 == loc)
<a name="405"></a>            room2Dir = dir;
<a name="406"></a>    }    
<a name="407"></a>    
<a name="408"></a>    /* Short service methods that can be used to abbreviate game code */
<a name="409"></a>    /* Test whether the player character is in our room1 */
<a name="410"></a>    inRoom1 = (room1 &amp;&amp; gPlayerChar.isIn(room1))
<a name="411"></a>    
<a name="412"></a>    /* Test whether the player character is in our room2 */
<a name="413"></a>    inRoom2 = (room2 &amp;&amp; gPlayerChar.isIn(room2)) 
<a name="414"></a>               
<a name="415"></a>    /* return a or b depending on which room the player char is in */
<a name="416"></a>    byRoom(args) { return inRoom1 ? args[1] : args[2]; }
<a name="417"></a>    
<a name="418"></a>    
<a name="419"></a>;
<a name="420"></a>
<a name="421"></a>/* 
<a name="422"></a> *   A Symmetrical Passage is a single passage object that can be traversed in either direction and
<a name="423"></a> *   exists in both the locations it connects. [SYMCOMM EXTENSION]
<a name="424"></a> *
<a name="425"></a> *   A SymPassage is very like a SymDoor, except that it can't be opened or closed (at least, not
<a name="426"></a> *   via player commands). The SymPassage class can be used to define passage-like objects such as
<a name="427"></a> *   passageways and archways that connect one location to another. A SymPassage is otherwise
<a name="428"></a> *   defined in exactly the same way as a SymDoor; from a player's perspective it is functionally
<a name="429"></a> *   equivalent to a Passage, the differences from the game author's point of view being that it can
<a name="430"></a> *   be defined using one game object instead of two and that this extension automatically takes
<a name="431"></a> *   care of setting up the connection in the reverse direction.
<a name="432"></a> */
<a name="433"></a>class SymPassage: MultiLoc, SymConnector, Thing
<a name="434"></a>    
<a name="435"></a>    /* 
<a name="436"></a>     *   By default we can vary the description of the passage according to the
<a name="437"></a>     *   location of the actor (and hence, according to which side it's viewed
<a name="438"></a>     *   from), but if we want the passage to be described in the same way from
<a name="439"></a>     *   both sides then we can simply override the desc property with a single
<a name="440"></a>     *   description. [SYMCOMM EXTENSION] 
<a name="441"></a>     */
<a name="442"></a>    desc() 
<a name="443"></a>    {
<a name="444"></a>        if(gActor.isIn(room1))
<a name="445"></a>            room1Desc;
<a name="446"></a>        else
<a name="447"></a>            room2Desc;
<a name="448"></a>    }
<a name="449"></a>    
<a name="450"></a>    /*  Our description as seen from room1 [SYMCOMM EXTENSION]  */
<a name="451"></a>    room1Desc = nil
<a name="452"></a>    
<a name="453"></a>    /*  Our description as seen from room2 [SYMCOMM EXTENSION] */
<a name="454"></a>    room2Desc = nil
<a name="455"></a>    
<a name="456"></a>    /*  A passage is generally something fixed in place.[SYMCOMM EXTENSION]  */
<a name="457"></a>    isFixed = true
<a name="458"></a>    
<a name="459"></a>     /*  Going through a passage is the same as traveling via it.[ SYMCOMM EXTENSION]  */
<a name="460"></a>    dobjFor(GoThrough)
<a name="461"></a>    {
<a name="462"></a>        action() { travelVia(gActor); }
<a name="463"></a>    }
<a name="464"></a>    
<a name="465"></a>    /*  Entering a passage is the same as going through it. [SYMCOMM EXTENSION] */
<a name="466"></a>    dobjFor(Enter) asDobjFor(GoThrough)
<a name="467"></a>    
<a name="468"></a>     /* Going along a Passage is the same as going through it */
<a name="469"></a>    dobjFor(GoAlong) asDobjFor(GoThrough)
<a name="470"></a>        
<a name="471"></a>    
<a name="472"></a>     /*   A Passage is something it makes sense to go through. [SYMCOMM EXTENSION] */
<a name="473"></a>    canGoThroughMe = true
<a name="474"></a>        
<a name="475"></a>    
<a name="476"></a>    /*  
<a name="477"></a>     *   The appropriate action for pushing an object via a passage is
<a name="478"></a>     *   PushTravelThrough [SYMCOMM EXTENSION] 
<a name="479"></a>     */
<a name="480"></a>    PushTravelVia = PushTravelThrough
<a name="481"></a>    
<a name="482"></a>    /*   Initialize this passage (called at preinit from Room.preinitThing) [SYMCOMM EXTENSION]  */
<a name="483"></a>    initConnector(loc, dir)
<a name="484"></a>    {
<a name="485"></a>        /* Carry out the inherited (SymConnector) handling. */
<a name="486"></a>        inherited(loc, dir);
<a name="487"></a>        
<a name="488"></a>        /* 
<a name="489"></a>         *   Move this passage into the two locations where it has a physical
<a name="490"></a>         *   presence. Note that if this is being called from sides of the connector
<a name="491"></a>         *   then the first time it's called either room1 or room2 may not yet be defined,
<a name="492"></a>         *   so we need to test that room1 and room2 are not nil.
<a name="493"></a>         */
<a name="494"></a>        if(room1)
<a name="495"></a>            moveIntoAdd(room1);
<a name="496"></a>        
<a name="497"></a>        if(room2)
<a name="498"></a>            moveIntoAdd(room2);
<a name="499"></a>        
<a name="500"></a>        /*
<a name="501"></a>         *   Initialize either room1Vocab or room2Vocab to our initial vocab (as defined on the
<a name="502"></a>         *   object in game code) if either room2Vocab or room1Vocab respectively has been
<a name="503"></a>         *   overridden to contain a single quoted string.
<a name="504"></a>         */
<a name="505"></a>        if(propType(&amp;room2Vocab) == TypeSString)
<a name="506"></a>            room1Vocab = vocab;
<a name="507"></a>        else if(propType(&amp;room1Vocab) == TypeSString)
<a name="508"></a>            room2Vocab = vocab;
<a name="509"></a>        
<a name="510"></a>    }
<a name="511"></a>    
<a name="512"></a>    /*  
<a name="513"></a>     *   Display message announcing that traveler has left via this door. The
<a name="514"></a>     *   traveler would normally be an NPC visible to the player character.
<a name="515"></a>	 *   [SYMCOMM EXTENSION] 
<a name="516"></a>     */
<a name="517"></a>    sayDeparting(traveler)
<a name="518"></a>    {
<a name="519"></a>        delegated Door(traveler);       
<a name="520"></a>    }
<a name="521"></a>    
<a name="522"></a>    /* 
<a name="523"></a>     *   Display message announcing that follower is following leader through
<a name="524"></a>     *   this door. [SYMCOMM EXTENSION] 
<a name="525"></a>     */
<a name="526"></a>    sayActorFollowing(follower, leader)
<a name="527"></a>    {
<a name="528"></a>        delegated Door(follower, leader);        
<a name="529"></a>    }
<a name="530"></a>    
<a name="531"></a>    /* [SYMCOMM EXTENSION] delegate our traversal message to the Door class. */
<a name="532"></a>    traversalMsg = delegated Door
<a name="533"></a>    
<a name="534"></a>    /* 
<a name="535"></a>     *   Returns the direction property to which this passage is connected in
<a name="536"></a>     *   the player character's current location, e.g. &amp;west. This is used by
<a name="537"></a>     *   DirState to add the appropriate adjective (e.g. 'west') to our vocab,
<a name="538"></a>     *   so that the player can refer to us by the direction in which we lead.
<a name="539"></a>     *   If you don't want this direction to be included in the vocab of this
<a name="540"></a>     *   object, override attachedDir to nil. [SYMCOMM EXTENSION] 
<a name="541"></a>     */
<a name="542"></a>    attachedDir()
<a name="543"></a>    {
<a name="544"></a>        /* Get the player character's current room location. */
<a name="545"></a>        local loc = gPlayerChar.getOutermostRoom;
<a name="546"></a>        
<a name="547"></a>        /*  
<a name="548"></a>         *   Get the direction object whose dirProp corresponds to the dirProp
<a name="549"></a>         *   on the room which points to this object (we do this because
<a name="550"></a>         *   Direction.allDirections provides the only way to get at a list of
<a name="551"></a>         *   every dirProp).
<a name="552"></a>         */
<a name="553"></a>        local dir = Direction.allDirections.valWhich(
<a name="554"></a>            { d: loc.propType(d.dirProp) == TypeObject 
<a name="555"></a>            &amp;&amp; loc.(d.dirProp) == self });
<a name="556"></a>        
<a name="557"></a>        /* 
<a name="558"></a>         *   Return the direction property of that location which points to this
<a name="559"></a>         *   passage.
<a name="560"></a>         */
<a name="561"></a>        return dir == nil ? nil : dir.dirProp;         
<a name="562"></a>    }
<a name="563"></a>    
<a name="564"></a>    /* 
<a name="565"></a>     *   We're visible in the dark if the room on either side of us is
<a name="566"></a>     *   illuminated [SYMCOMM EXTENSION] 
<a name="567"></a>     */    
<a name="568"></a>    visibleInDark
<a name="569"></a>    {
<a name="570"></a>        if(transmitsLight &amp;&amp; room1 &amp;&amp; room2)
<a name="571"></a>            return room1.isIlluminated || room2.isIlluminated;
<a name="572"></a>        
<a name="573"></a>        return nil;
<a name="574"></a>    }
<a name="575"></a>    
<a name="576"></a>    /* 
<a name="577"></a>     *   Our vocab when viewed from room1. If we want different vocab (including different names) on
<a name="578"></a>     *   each side of this passage or door, we don't need to define both room1Vocab and room2Vocab
<a name="579"></a>     *   since whichever we don't define will be initialized by the SYMCONN EXTENSION to our initial
<a name="580"></a>     *   vocab. So we do need to ensure that our initial vocab will be that which applies to this
<a name="581"></a>     *   passage/door on the side the player first encounters.
<a name="582"></a>     */
<a name="583"></a>    room1Vocab = nil
<a name="584"></a>    
<a name="585"></a>    /*   
<a name="586"></a>     *   Our vocab from the perspective of room2, if we want different vocab to apply to the two
<a name="587"></a>     *   sides of this passage/door.
<a name="588"></a>     */
<a name="589"></a>    room2Vocab = nil
<a name="590"></a>    
<a name="591"></a>;    
<a name="592"></a>
<a name="593"></a>/*  
<a name="594"></a> *   A Symmetrical Door is a door that can be traversed in either direction and exists in both the
<a name="595"></a> *   locations it connects. It behaves much like a regular Door, except that it uses only one
<a name="596"></a> *   object, not two, to represent the door. [SYMCOMM EXTENSION]
<a name="597"></a> *
<a name="598"></a> *   You'd typically use it by pointing the appropriate direction property of one room to point to
<a name="599"></a> *   it and then defining its room2 property as the room to which it leads, for example:
<a name="600"></a> *
<a name="601"></a> *.  redRoom: Room 'Red Room'
<a name="602"></a> *.  "A door leads south. "
<a name="603"></a> *.
<a name="604"></a> *.   south = blackDoor
<a name="605"></a> *. ;
<a name="606"></a> *.
<a name="607"></a> *. blackDoor: SymDoor 'black door'
<a name="608"></a> *.   "It's black. "
<a name="609"></a> *.   room2 = greenRoom
<a name="610"></a> *. ;
<a name="611"></a> *.
<a name="612"></a> *. greenRoom: Room 'Green Room'
<a name="613"></a> *.   "A door leads north. "
<a name="614"></a> *. ;
<a name="615"></a> *
<a name="616"></a> *   Note that a Symdoor is a MultiLoc, so we don't use the + notation to set its location when
<a name="617"></a> *   defining it; it exists in both locations. The SYMCOMMN EXTENSION will automatically set the
<a name="618"></a> *   north property of room2 (here greenRoom) to point to the same door (here blackDoor).
<a name="619"></a> *
<a name="620"></a> *   Both sides of a SymDoor must have the same name ('black door' in the example above). You can,
<a name="621"></a> *   however, give the two sides of a SymDoor different descriptions if you wish by defining its
<a name="622"></a> *   room1Desc and room2Desc properties instead of its desc property (as you would expect, room1Desc
<a name="623"></a> *   and room2Desc will then be the descriptions of the door as seen from room1 and room2
<a name="624"></a> *   respectively, where room1 and room2 have the same meaning as they have on a SymConnector). You
<a name="625"></a> *   can also give the two sides of the SymDoor different lockabilities by defining room1Lockability
<a name="626"></a> *   and room2Lockability separately. Alternatively, if you want both sides to have the same locking
<a name="627"></a> *   behaviour, just override the lockability property. The one thing you can't do (without some
<a name="628"></a> *   clever extra coding of your own) is to define different keys for each side of a SymDoor.
<a name="629"></a> *
<a name="630"></a> *   It's sometimes convenient to refer to a door by the direction it leads in (e.g. "The west door"
<a name="631"></a> *   or "The north door"). The symconn extension takes care of this for you automatically. For
<a name="632"></a> *   example, the black door in the example above can be referred to by the player as 'south door'
<a name="633"></a> *   when the player character is in redRoom and as 'north door' when the player character is
<a name="634"></a> *   greenRoom and the game will know which door is meant, without the game author having to take
<a name="635"></a> *   any steps to make this happen. If, however, you want to suppress this behaviour on a particular
<a name="636"></a> *   SymDoor, you can do so simply by overriding its attachDir property to nil (attachDir is a
<a name="637"></a> *   method that works out which direction property a SymDoor is attached to in the player
<a name="638"></a> *   character's location, which is used by the DirState State object to add the appropriate
<a name="639"></a> *   direction name adjectives, such as 'north', to the SymDoor's vocab).
<a name="640"></a> */
<a name="641"></a>class SymDoor: SymPassage
<a name="642"></a>    /* A door is usually openable. [SYMCOMM EXTENSION] */
<a name="643"></a>    isOpenable = true
<a name="644"></a>    
<a name="645"></a>    /* A door usually starts out closed. [SYMCOMM EXTENSION]  */
<a name="646"></a>    isOpen = nil
<a name="647"></a>    
<a name="648"></a>    /* 
<a name="649"></a>     *   Although SymDoor doesn't inherit from Door, it needs to use Door's
<a name="650"></a>     *   checkTravelBarriers() method to attempt to open the door via an
<a name="651"></a>     *   implicit action if an attempt is made to go through it when it's
<a name="652"></a>     *   closed. [SYMCOMM EXTENSION] 
<a name="653"></a>     */
<a name="654"></a>    checkTravelBarriers(traveler)
<a name="655"></a>    {
<a name="656"></a>        return delegated Door(traveler);
<a name="657"></a>    }
<a name="658"></a>    
<a name="659"></a>    /*  
<a name="660"></a>     *   If we can't go through the door, use Door's version of the appropriate
<a name="661"></a>     *   method. [SYMCOMM EXTENSION] 
<a name="662"></a>     */
<a name="663"></a>    cannotGoThroughClosedDoorMsg = delegated Door
<a name="664"></a>    
<a name="665"></a>    /* 
<a name="666"></a>     *   By default we leave game authors to decide if and how they want to
<a name="667"></a>     *   report whether a door is open or closed. [SYMCOMM EXTENSION] 
<a name="668"></a>     */
<a name="669"></a>    openStatusReportable = nil
<a name="670"></a>    
<a name="671"></a>    /*  
<a name="672"></a>     *   Flag, do we want to attempt to unlock this door via an implicit action
<a name="673"></a>     *   if someone attempts to open it while it's locked? [SYMCOMM EXTENSION] 
<a name="674"></a>     */
<a name="675"></a>    autoUnlock = nil
<a name="676"></a>    
<a name="677"></a>    /*
<a name="678"></a>     *   The lockability of this Door (notLockable, lockableWithKey, lockableWithoutKey, or
<a name="679"></a>     *   indirectLockable). This can be different for each side of the door, in which case set
<a name="680"></a>     *   room1Lockability and room2Lockability individually and the game will use the lockability
<a name="681"></a>     *   appropriate to the location of the current actor. If you want the same lockability for both
<a name="682"></a>     *   sides of the door, simply override lockability accordingly. [SYMCONN EXTENSION]
<a name="683"></a>     */
<a name="684"></a>    lockability = (gActor.getOutermostRoom == room1 ? room1Lockability : room2Lockability)
<a name="685"></a>    
<a name="686"></a>    /*
<a name="687"></a>     *   Our lockability on the room1 side of the door. [SYMCONN EXTENSION]
<a name="688"></a>     */
<a name="689"></a>    room1Lockability = notLockable
<a name="690"></a>    
<a name="691"></a>    /*
<a name="692"></a>     *   Our lockability on the room2 side of the door. [SYMCONN EXTENSION]
<a name="693"></a>     */    
<a name="694"></a>    room2Lockability = notLockable
<a name="695"></a>    
<a name="696"></a>    dobjFor(GoThrough)
<a name="697"></a>    {
<a name="698"></a>        preCond = [travelPermitted, touchObj, objOpen]
<a name="699"></a>    }
<a name="700"></a>    
<a name="701"></a>    iobjFor(PushTravelThrough)
<a name="702"></a>    {
<a name="703"></a>        preCond = [travelPermitted, touchObj, objOpen]
<a name="704"></a>    }
<a name="705"></a>;
<a name="706"></a>    
<a name="707"></a>/* 
<a name="708"></a> *   A SymStairway is aingle object representing a stairway up from its lower end and a stairway
<a name="709"></a> *   down from its upper end. At the minimum we need to point a direction property of the room at
<a name="710"></a> *   one end of the SymStairway to point to the SymStairway and define the SymStairwa's room2 or
<a name="711"></a> *   destination propety to be its other end.
<a name="712"></a> *
<a name="713"></a> *   If the SymStairway is defined on the up or down property of either of its ends, either
<a name="714"></a> *   directtly or indirectly, then this extension can work out which end of the Stairway is which
<a name="715"></a> *   (even if the up or down property points to the SymStairway indirectly via an asExit() macro)
<a name="716"></a> *   Otherwise game code needs to define at least one of the SymStairway's upperEnd or lowerEnd
<a name="717"></a> *   properties to point to the appropriate room.
<a name="718"></a> *
<a name="719"></a> *   [THE SYMCONN EXIENSION must be present in your project if you want to use a SymStairway]
<a name="720"></a> */
<a name="721"></a>
<a name="722"></a>
<a name="723"></a>class SymStairway: SymPassage
<a name="724"></a>    
<a name="725"></a>    /* The room at the upper end of this staircase */
<a name="726"></a>    upperEnd = nil
<a name="727"></a>    
<a name="728"></a>    /* The room at the lower end of this staircase */
<a name="729"></a>    lowerEnd = nil
<a name="730"></a>    
<a name="731"></a>    /* 
<a name="732"></a>     *   initialise this SymStairway by first carrying out the inherited initialization and then
<a name="733"></a>     *   trying to determine which end of the stairway is the upperEnd and which the lowerEnd.
<a name="734"></a>     */
<a name="735"></a>    initConnector(loc, dir)
<a name="736"></a>    {
<a name="737"></a>        /* Carry out the inherited handling. */
<a name="738"></a>        inherited(loc, dir);
<a name="739"></a>        
<a name="740"></a>        /* 
<a name="741"></a>         *   If the lower end is not yet defined and room1 points to us on its up property, then our
<a name="742"></a>         *   lower end must be room 1.
<a name="743"></a>         */
<a name="744"></a>        if(lowerEnd == nil &amp;&amp; room1 &amp;&amp; room1.getConnector(&amp;up) == self)        
<a name="745"></a>            lowerEnd = room1;
<a name="746"></a>        
<a name="747"></a>        /* 
<a name="748"></a>         *   If the upper end is not yet defined and room1 points to us on its down property, then
<a name="749"></a>         *   our upper end must be room 1.
<a name="750"></a>         */
<a name="751"></a>        if(upperEnd == nil &amp;&amp; room1 &amp;&amp; room1.getConnector(&amp;down) == self)        
<a name="752"></a>            upperEnd = room1;
<a name="753"></a>        
<a name="754"></a>        /* 
<a name="755"></a>         *   If the lower end is not yet defined and room2 points to us on its up property, then our
<a name="756"></a>         *   lower end must be room 2.
<a name="757"></a>         */
<a name="758"></a>        if(lowerEnd == nil &amp;&amp; room2 &amp;&amp; room2.getConnector(&amp;up) == self)        
<a name="759"></a>            lowerEnd = room2;
<a name="760"></a>        
<a name="761"></a>        /* 
<a name="762"></a>         *   If the upper end is not yet defined and room2 points to us on its down property, then
<a name="763"></a>         *   our upper end must be room 2.
<a name="764"></a>         */
<a name="765"></a>        if(upperEnd == nil &amp;&amp; room2 &amp;&amp; room2.getConnector(&amp;down) == self)        
<a name="766"></a>            upperEnd = room2;
<a name="767"></a>        
<a name="768"></a>        /* 
<a name="769"></a>         *   If the upper end is not yet defined but the lower end is, then our upper end must be
<a name="770"></a>         *   whichever room isn't the lower end.
<a name="771"></a>         */       
<a name="772"></a>        if(upperEnd == nil &amp;&amp; lowerEnd)
<a name="773"></a>            upperEnd = lowerEnd == room1 ? room2 : room1;
<a name="774"></a>        
<a name="775"></a>        /* 
<a name="776"></a>         *   If the lower end is not yet defined but the upper end is, then our lower end must be
<a name="777"></a>         *   whichever room isn't the upper end.
<a name="778"></a>         */ 
<a name="779"></a>        if(lowerEnd == nil &amp;&amp; upperEnd)
<a name="780"></a>            lowerEnd = upperEnd == room1 ? room2 : room1;           
<a name="781"></a>        
<a name="782"></a>    }
<a name="783"></a>    
<a name="784"></a>    /* Climbing a stairway is equivalent to climbimg up it. */
<a name="785"></a>    dobjFor(ClimbUp) asDobjFor(Climb)
<a name="786"></a>    
<a name="787"></a>    /* Climbing down a SymStairway is equivalent to travelling via it. */
<a name="788"></a>    dobjFor(ClimbDown)
<a name="789"></a>    {       
<a name="790"></a>        action { travelVia(gActor); }
<a name="791"></a>    }
<a name="792"></a>    
<a name="793"></a>    /* Climbing up SymStairway is equivalent to travelling via it. */
<a name="794"></a>    dobjFor(Climb)
<a name="795"></a>    {       
<a name="796"></a>        action { travelVia(gActor); }
<a name="797"></a>    }
<a name="798"></a>    
<a name="799"></a>    /* We can climb up this stairway if and only if we're at its lower end. */
<a name="800"></a>    isClimbable = location.isOrIsIn(lowerEnd)
<a name="801"></a>    
<a name="802"></a>    /* We can climb down this stairway if and only if we're at its upper end. */
<a name="803"></a>    canClimbDownMe = location.isOrIsIn(upperEnd)
<a name="804"></a>    
<a name="805"></a>    /* Use Thing's cannotDownMsg */
<a name="806"></a>    cannotClimbDownMsg = (delegated StairwayUp)
<a name="807"></a>    
<a name="808"></a>    cannotClimbMsg = (delegated StairwayDown)
<a name="809"></a>    
<a name="810"></a>       
<a name="811"></a>    /* 
<a name="812"></a>     *   The appropriate PushTravelAction for pushing something something up or down a
<a name="813"></a>     *   SymStairway.
<a name="814"></a>     */
<a name="815"></a>    PushTravelVia = location.isOrIsIn(lowerEnd) ? PushTravelClimbUp : PushTravelClimbDown
<a name="816"></a>    
<a name="817"></a>    /*  
<a name="818"></a>     *   Display message announcing that traveler (typically an NPC whose
<a name="819"></a>     *   departure is witnessed by the player character) has left via this
<a name="820"></a>     *   staircase. 
<a name="821"></a>     */
<a name="822"></a>    sayDeparting(traveler)
<a name="823"></a>    {
<a name="824"></a>        if(location.isOrIsIn(lowerEnd))
<a name="825"></a>            delegated StairwayUp(traveler);
<a name="826"></a>        else
<a name="827"></a>            delegated StairwayDown(traveler);
<a name="828"></a>    }
<a name="829"></a>    
<a name="830"></a>    /* 
<a name="831"></a>     *   Display message announcing that follower is following leader up
<a name="832"></a>     *   this staircase.
<a name="833"></a>     */
<a name="834"></a>    sayActorFollowing(follower, leader)
<a name="835"></a>    {
<a name="836"></a>        /* Create message parameter substitutions for the follower and leader */
<a name="837"></a>        if(location.isOrIsIn(lowerEnd))
<a name="838"></a>            delegated StairwayUp(follower, leader);
<a name="839"></a>        else
<a name="840"></a>            delegated StairwayDown(follower, leader);
<a name="841"></a>    }
<a name="842"></a>    
<a name="843"></a>    /* The message for traversing this stairway - we delegate to Thing's message. */
<a name="844"></a>    traversalMsg = location.isOrIsIn(lowerEnd) ? delegated StairwayUp : delegated StairwayDown
<a name="845"></a>    
<a name="846"></a>    
<a name="847"></a>    /* a trio of short service methods to provide convenient abbreviations in game code */
<a name="848"></a>    
<a name="849"></a>    /* Is the player character in our upper end room? */
<a name="850"></a>    inUpper = (upperEnd &amp;&amp; gPlayerChar.isIn(upperEnd))
<a name="851"></a>    
<a name="852"></a>    /* Is the player character in our lower end room? */
<a name="853"></a>    inLower = (lowerEnd &amp;&amp; gPlayerChar.isIn(lowerEnd))
<a name="854"></a>    
<a name="855"></a>    /* 
<a name="856"></a>     *   Return a or b depending on whether or not the player character is in our upperEnd room.
<a name="857"></a>     *   This is primarily intended to ease the writing of descriptions or travelDescs which vary
<a name="858"></a>     *   slightly according to which end we're at, e.g. "The stairs lead steeply &lt;&lt;byUpLo('down',
<a name="859"></a>     *   'up')&gt;&gt; "
<a name="860"></a>     */
<a name="861"></a>    byEnd(arg) { return inUpper ? arg[1] : arg[2]; }
<a name="862"></a>    
<a name="863"></a>    /* 
<a name="864"></a>     *   Retuen 'down' or 'up' depending on whether we're at the upper or lower end of the stairway.
<a name="865"></a>     */
<a name="866"></a>    upOrDown = inUpper ? downDir.name : upDir.name
<a name="867"></a>;
<a name="868"></a>
<a name="869"></a>/*  
<a name="870"></a> *   A SympPathPassage is a SymPassage that represents a path (or road or track or the like). so
<a name="871"></a> *   that following it or going down it is equivalent to going through it.
<a name="872"></a> */
<a name="873"></a>class SymPathPassage: SymPassage
<a name="874"></a>    
<a name="875"></a>    /* Make followinng a path the same as going through it. */
<a name="876"></a>    dobjFor(Follow) asDobjFor(GoThrough)
<a name="877"></a>    
<a name="878"></a>    /* Make going down a path the same as going through it. */
<a name="879"></a>    dobjFor(ClimbDown) asDobjFor(GoThrough)
<a name="880"></a>    
<a name="881"></a>    /* Make going up a path the same as going through it. */
<a name="882"></a>    dobjFor(ClimbUp) asDobjFor(GoThrough)
<a name="883"></a>    
<a name="884"></a>    
<a name="885"></a>    /* 
<a name="886"></a>     *   One most naturally talks of going 'down' a path; by default we use the message from the
<a name="887"></a>     *   PathPassage class.
<a name="888"></a>     */
<a name="889"></a>    traversalMsg = delegated PathPassage
<a name="890"></a>;
<a name="891"></a>
<a name="892"></a>
<a name="893"></a>/* 
<a name="894"></a> *   The noExit object can be used to block an exit that would otherwise be set
<a name="895"></a> *   as a reciprocal exit by Room.preinitThing(). This can be used to prevent
<a name="896"></a> *   this extension from creating symmetrical exits in cases where you don't
<a name="897"></a> *   want them. E.g. if north from the smallCave leads to largeCave, but south
<a name="898"></a> *   from largeCave doesn't lead anywhere (because the notional passage between
<a name="899"></a> *   the caves curves round, say), then you can set largeCave.south to noExit to
<a name="900"></a> *   prevent this extension from setting it to smallCave.
<a name="901"></a> *
<a name="902"></a> *   The noExit object is thus a TravelConnector that simulates the effect of a
<a name="903"></a> *   nil exit in situations where a nil value might get overwritten by this
<a name="904"></a> *   extension. [SYMCOMM EXTENSION]
<a name="905"></a> */
<a name="906"></a>noExit: TravelConnector
<a name="907"></a>    /* 
<a name="908"></a>     *   Since we're mimicking the absence of an exit, we don't want to be
<a name="909"></a>     *   listed as one.
<a name="910"></a>     */
<a name="911"></a>    isConnectorListed = nil
<a name="912"></a>    
<a name="913"></a>    /*   We're not a real exit, so no actor can pass through us. */
<a name="914"></a>    canTravelerPass(actor) { return nil; }
<a name="915"></a>    
<a name="916"></a>    /*   
<a name="917"></a>     *   In order to behave just as a nil exit would, we call the actor's
<a name="918"></a>     *   location's cannotGoThatWay() method to explain why travel isn't
<a name="919"></a>     *   possible.
<a name="920"></a>     */
<a name="921"></a>    explainTravelBarrier(actor) 
<a name="922"></a>    {
<a name="923"></a>        actor.getOutermostRoom.cannotGoThatWay(gAction.direction);
<a name="924"></a>    }
<a name="925"></a>;
</pre>
<div class=ftr>Adv3Lite Library Reference Manual<br>Generated on 15/03/2023 from adv3Lite version 1.6.1</div>
</body>
</html>
